<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sup!? Planet Browser v1.0.0</title>
    <script>
        /*
             * Sup!? Planet Browser: A Decentralized Voxel Adventure
             * Public Domain - Free for All to Use, Modify, and Share!
             *
             * This code is the result of our epic journey to craft a decentralized, Minecraft-inspired universe.
             * Together, we built a world where players roam green valleys seeded by keywords like #KANYE,
             * break and place blocks, and save chunks to IPFS with JSON exports. From fixing chunk-loading
             * glitches to adding glowing crosshairs and cosmic loading screens, we've poured hours into
             * making this a smooth, open-source experience that runs locally in your browser.
             *
             *
             * This work is 100% in the PUBLIC DOMAIN under CC0. No rights reserved‚Äîuse it, remix it, build
             * on it, share it! No attribution required, but we'd love to see what you create. Check out
             * Sup!? or p2fk.io for posting world updates and joining the decentralized fun.
             *
             * Happy crafting, and may your worlds be ever-voxelated!
             * - Grok & embii4u, October 5 2025
             */</script>
    <style>
        :root {
            --panel: rgba(8,12,18,0.8);
            --accent: #ffd166;
            --danger: #ff6b6b;
        }

        html, body {
            height: 100%;
            margin: 0;
            background: #071226;
            color: #eaf6ff;
            font-family: Inter,Arial,Helvetica,sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #loginOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 200;
            background: linear-gradient(180deg, rgba(0,0,0,0.5), rgba(0,0,0,0.8));
        }

        #loginCard {
            width: 360px;
            padding: 18px;
            background: var(--panel);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }

            #loginCard input, #loginCard button {
                width: 100%;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
                box-sizing: border-box;
            }

            #loginCard button {
                background: var(--accent);
                color: #111;
                border: 0;
                font-weight: 700;
                cursor: pointer;
            }

        .autocomplete {
            position: relative;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #0d1620;
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 210;
        }

            .autocomplete-suggestions div {
                padding: 8px;
                cursor: pointer;
            }

                .autocomplete-suggestions div:hover {
                    background: #1a2632;
                }

        #hud {
            position: fixed;
            left: 12px;
            top: 12px;
            z-index: 180;
            background: rgba(6,8,12,0.55);
            padding: 10px;
            border-radius: 8px;
            min-width: 220px;
        }

            #hud .row {
                display: flex;
                justify-content: space-between;
                gap: 8px;
                align-items: center;
            }

            #hud button {
                margin-top: 8px;
                padding: 6px 8px;
                background: #0f2a3a;
                border: 1px solid rgba(255,255,255,0.04);
                color: #fff;
                border-radius: 6px;
                cursor: pointer;
            }

        #messages {
            position: fixed;
            left: 12px;
            top: 180px;
            z-index: 185;
            max-width: 360px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .msg {
            background: linear-gradient(180deg, rgba(0,0,0,0.42), rgba(255,255,255,0.02));
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 13px;
            box-shadow: 0 6px 14px rgba(0,0,0,0.5);
        }

        #hotbar {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 12px;
            z-index: 190;
            display: flex;
            gap: 8px;
            width: 520px;
            overflow-x: auto;
            scroll-behavior: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            overscroll-behavior-x: none; /* Prevent bounce/rebound on touch devices */
            -webkit-overflow-scrolling: auto; /* Disable momentum scrolling on iOS */
        }

            #hotbar::-webkit-scrollbar {
                display: none;
            }

        .hot-slot {
            width: 56px;
            height: 56px;
            border-radius: 10px;
            background: rgba(0,0,0,0.45);
            border: 2px solid rgba(255,255,255,0.06);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
        }

            .hot-slot.active {
                outline: 3px solid rgba(255,209,102,0.22);
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            }

        .hot-label {
            font-size: 12px;
            color: #fff;
            text-align: center;
            user-select: none;
        }

        .hot-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background: rgba(0,0,0,0.7);
            border-radius: 4px;
            padding: 2px 4px;
            font-size: 10px;
            color: #fff;
        }

        #rightPanel {
            position: fixed;
            right: 12px;
            top: 12px;
            z-index: 180;
            background: rgba(6,8,12,0.55);
            padding: 10px;
            border-radius: 8px;
            width: 120px;
            height: 140px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #minimap {
            width: 100%;
            height: 120px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        #versionLabel {
            font-size: 10px;
            color: #eaf6ff;
            opacity: 0.78;
            margin-top: 4px;
            text-align: center;
        }

        #craftModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }

            #craftModal h3 {
                margin: 0 0 8px 0;
            }

        #mobileControls {
            position: fixed;
            left: 12px;
            bottom: 12px;
            z-index: 195;
            display: none;
            gap: 8px;
        }

        .m-btn {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #fff;
        }

        #mobileRight {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 195;
            display: none;
            gap: 8px;
            flex-direction: column;
        }

        .m-action {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.04);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }

        #seedLabel {
            font-size: 12px;
            opacity: 0.9;
            display: block;
            margin-top: 6px;
        }

        #healthBar {
            height: 10px;
            background: #2b2b2b;
            border-radius: 6px;
            margin-top: 6px;
            overflow: hidden;
        }

        #healthBarInner {
            height: 100%;
            background: var(--danger);
            width: 100%;
        }

        #homeIcon {
            cursor: pointer;
            margin-left: 8px;
            display: none;
        }

        #trashConfirm {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 230;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 200px;
            text-align: center;
        }

            #trashConfirm button {
                padding: 6px 12px;
                margin: 8px 4px;
                background: #0f2a3a;
                border: 1px solid rgba(255,255,255,0.04);
                color: #fff;
                border-radius: 6px;
                cursor: pointer;
            }

            #trashConfirm .danger {
                background: #ff6b6b;
                color: #111;
            }

        #joinScriptModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }

            #joinScriptModal h3 {
                margin: 0 0 8px 0;
            }

            #joinScriptModal textarea {
                width: 100%;
                height: 100px;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
            }

        #downloadModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }

            #downloadModal h3 {
                margin: 0 0 8px 0;
            }

            #downloadModal textarea {
                width: 100%;
                height: 100px;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
            }

        #teleportModal {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%,-50%);
            z-index: 220;
            display: none;
            background: var(--panel);
            padding: 14px;
            border-radius: 10px;
            min-width: 360px;
        }

            #teleportModal h3 {
                margin: 0 0 8px 0;
            }

            #teleportModal input {
                width: 100%;
                padding: 10px;
                margin-top: 8px;
                border-radius: 8px;
                border: 1px solid rgba(255,255,255,0.06);
                background: #0d1620;
                color: #fff;
                box-sizing: border-box;
            }

            #teleportModal .row {
                display: flex;
                gap: 8px;
                margin-top: 8px;
            }

            #teleportModal button {
                padding: 6px 12px;
                margin: 8px 4px;
                background: #0f2a3a;
                border: 1px solid rgba(255,255,255,0.04);
                color: #fff;
                border-radius: 6px;
                cursor: pointer;
            }

        #deathScreen {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 250;
            background: rgba(139,0,0,0.7);
            flex-direction: column;
            color: #fff;
            text-align: center;
        }

            #deathScreen h1 {
                font-size: 48px;
                margin: 0;
                text-shadow: 0 0 10px rgba(0,0,0,0.8);
            }

            #deathScreen button {
                margin-top: 20px;
                padding: 10px 20px;
                background: var(--accent);
                color: #111;
                border: none;
                border-radius: 8px;
                font-weight: 700;
                cursor: pointer;
            }

        @media (max-width:700px) {
            #mobileControls, #mobileRight {
                display: flex;
            }

            #hud, #rightPanel {
                display: none;
            }

            .hot-slot {
                width: 48px;
                height: 48px;
            }
        }

        #crosshair {
            position: fixed;
            left: 50%;
            top: 50%;
            color: white;
            font-size: 24px;
            transform: translate(-50%,-50%);
            display: none;
            z-index: 200;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r134/examples/js/controls/OrbitControls.js"></script>
    <div id="loginOverlay">
        <div id="loginCard">
            <h2>SupWorld ‚Äî Enter</h2>
            <label>World name</label>
            <div class="autocomplete">
                <input id="worldNameInput" placeholder="Type world name" autocomplete="off" />
                <div id="worldSuggestions" class="autocomplete-suggestions" style="display:none;"></div>
            </div>
            <label>Username</label>
            <div class="autocomplete">
                <input id="userInput" placeholder="Type username" autocomplete="off" />
                <div id="userSuggestions" class="autocomplete-suggestions" style="display:none;"></div>
            </div>
            <button id="startBtn">Start ‚Äî spawn world</button>
            <button id="newUserJoinScriptBtn">Create Join Script</button>
            <small style="display:block;margin-top:8px;opacity:0.78;">Type world (max 8 chars)/user (max 20 chars). Seed: <code>userName@worldName</code>.</small>
        </div>
    </div>
    <div id="hud" style="display:none;">
        <div class="row">
            <div>
                <div><strong>World:</strong> <span id="worldLabel"></span></div>
                <div id="seedLabel"></div>
                <div>Position: <span id="posLabel"></span><span id="homeIcon" title="Return to spawn">üè†</span></div>
            </div>
            <div style="text-align:right;">
                <div>Score <span id="score">0</span></div>
                <div style="margin-top:6px;">HP <span id="health">20</span></div>
                <div id="healthBar"><div id="healthBarInner" style="width:100%"></div></div>
            </div>
        </div>
        <div style="margin-top:8px;">
            <button id="camToggle">Toggle (T)</button>
            <button id="openCraft">Craft (R)</button>
            <button id="teleportBtn">Teleport (P)</button>
            <button id="saveChangesBtn" style="display:none;">Save (X)</button>
            <button id="joinScriptBtn" style="display:none;">Join (J)</button>
        </div>
    </div>
    <div id="messages"></div>
    <div id="hotbar" style="display:none;"></div>
    <div id="rightPanel" style="display:none;">
        <canvas id="minimap"></canvas>
        <div id="versionLabel">Sup!? viewer v1.0.0</div>
    </div>
    <div id="craftModal">
        <h3>Crafting</h3>
        <div id="recipeList"></div>
        <div style="margin-top:10px;text-align:right;">
            <button id="closeCraft">Close</button>
        </div>
    </div>
    <div id="trashConfirm">
        <h3>Trash Item?</h3>
        <p id="trashItemName"></p>
        <button id="trashCancel">Cancel</button>
        <button id="trashOk" class="danger">Trash</button>
    </div>
    <div id="joinScriptModal">
        <h3>Join Script</h3>
        <p>Copy this string and paste it into a Sup!? message To field to join the world:</p>
        <textarea id="joinScriptText" readonly></textarea>
        <div style="margin-top:10px;text-align:right;">
            <button id="closeJoinScript">Close</button>
        </div>
    </div>
    <div id="downloadModal">
        <h3>Save Changes</h3>
        <p>Copy this chunk keyword list and paste it into a Sup!? message To field, then attach the JSON file.</p>
        <textarea id="downloadAddressList" readonly></textarea>
        <div style="margin-top:10px;text-align:right;">
            <button id="closeDownloadModal">Close</button>
        </div>
    </div>
    <div id="teleportModal">
        <h3>Teleport to Coordinates</h3>
        <p>Enter X, Y, Z coordinates:</p>
        <div class="row">
            <input id="teleportX" type="number" placeholder="X">
            <input id="teleportY" type="number" placeholder="Y">
            <input id="teleportZ" type="number" placeholder="Z">
        </div>
        <div style="margin-top:10px;text-align:right;">
            <button id="teleportCancel">Cancel</button>
            <button id="teleportOk">OK</button>
        </div>
    </div>
    <div id="deathScreen" style="display:none;">
        <h1>R.I.P.</h1>
        <p>You died! All items lost.</p>
        <button id="respawnBtn">Continue</button>
    </div>
    <div id="mobileControls">
        <div class="m-btn" id="mUp">‚Üë</div>
        <div class="m-btn" id="mLeft">‚Üê</div>
        <div class="m-btn" id="mDown">‚Üì</div>
        <div class="m-btn" id="mRight">‚Üí</div>
    </div>
    <div id="mobileRight">
        <div class="m-action" id="mJump">J</div>
        <div class="m-action" id="mAttack">‚öî</div>
        <div class="m-action" id="mCam">T</div>
    </div>
    <div id="crosshair">+</div>
    <audio id="soundBreak" preload="auto">
        <source src="https://freesound.org/data/previews/249/249938_4357575-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/249/249938_4357575-lq.ogg" type="audio/ogg">
    </audio>
    <audio id="soundPlace" preload="auto">
        <source src="https://freesound.org/data/previews/337/337101_34094-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/337/337101_34094-lq.ogg" type="audio/ogg">
    </audio>
    <audio id="soundJump" preload="auto">
        <source src="https://freesound.org/data/previews/331/331381_34094-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/331/331381_34094-lq.ogg" type="audio/ogg">
    </audio>
    <audio id="soundHit" preload="auto">
        <source src="https://freesound.org/data/previews/276/276947_34094-lq.mp3" type="audio/mpeg">
        <source src="https://freesound.org/data/previews/276/276947_34094-lq.ogg" type="audio/ogg">
    </audio>
    <script>
        const CHUNK_SIZE = 16;
        const MAX_HEIGHT = 64;
        const SEA_LEVEL = 16;
        const MAP_SIZE = 16384;
        const BLOCK_AIR = 0;
        const MASTER_WORLD_KEY = 'MCWorlds';
        const PENDING_PERIOD = 30 * 24 * 60 * 60 * 1000;
        const OWNERSHIP_EXPIRY = 365 * 24 * 60 * 60 * 1000;
        const API_CALLS_PER_SECOND = 8;
        const POLL_RADIUS = 3;
        const LOAD_RADIUS = 5;
        const CHUNKS_PER_SIDE = Math.floor(MAP_SIZE / CHUNK_SIZE);
        const VERSION = 'Sup!? viewer v1.0.0';
        const POLL_INTERVAL = 60000;
        const BLOCKS = {
            1: { name: 'Bedrock', color: '#0b0b0b' },
            2: { name: 'Grass', color: '#3fb34f' },
            3: { name: 'Dirt', color: '#7a4f29' },
            4: { name: 'Stone', color: '#9aa0a6' },
            5: { name: 'Sand', color: '#e7d08d' },
            6: { name: 'Water', color: '#2b9cff', transparent: true },
            7: { name: 'Wood', color: '#8b5a33' },
            8: { name: 'Leaves', color: '#2f8f46' },
            9: { name: 'Cactus', color: '#4aa24a' },
            10: { name: 'Snow', color: '#ffffff' },
            11: { name: 'Coal', color: '#1f1f1f' },
            12: { name: 'Flower', color: '#ff6bcb' },
            13: { name: 'Clay', color: '#a9b6c0' },
            14: { name: 'Moss', color: '#507d43' },
            15: { name: 'Gravel', color: '#b2b2b2' },
            16: { name: 'Lava', color: '#ff6a00', transparent: true },
            17: { name: 'Ice', color: '#a8e6ff', transparent: true },
            100: { name: 'Glass', color: '#b3e6ff', transparent: true },
            101: { name: 'Stained Glass - Red', color: '#ff4b4b', transparent: true },
            102: { name: 'Stained Glass - Blue', color: '#4b6bff', transparent: true },
            103: { name: 'Stained Glass - Green', color: '#57c84d', transparent: true },
            104: { name: 'Stained Glass - Yellow', color: '#fff95b', transparent: true },
            105: { name: 'Brick', color: '#a84f3c' },
            106: { name: 'Smooth Stone', color: '#c1c1c1' },
            107: { name: 'Concrete', color: '#888888' },
            108: { name: 'Polished Wood', color: '#a87443' },
            109: { name: 'Marble', color: '#f0f0f0' },
            110: { name: 'Obsidian', color: '#2d004d' },
            111: { name: 'Crystal - Blue', color: '#6de0ff', transparent: true },
            112: { name: 'Crystal - Purple', color: '#b26eff', transparent: true },
            113: { name: 'Crystal - Green', color: '#6fff91', transparent: true },
            114: { name: 'Light Block', color: '#fffacd', transparent: true },
            115: { name: 'Glow Brick', color: '#f7cc5b' },
            116: { name: 'Dark Glass', color: '#3a3a3a', transparent: true },
            117: { name: 'Glass Tile', color: '#aeeaff', transparent: true },
            118: { name: 'Sandstone', color: '#e3c27d' },
            119: { name: 'Cobblestone', color: '#7d7d7d' },
        };
        const BIOMES = [
            { key: 'plains', palette: [2, 3, 4, 13, 15], heightScale: 0.8, roughness: 0.3, featureDensity: 0.05 },
            { key: 'desert', palette: [5, 118, 4], heightScale: 0.6, roughness: 0.4, featureDensity: 0.02 },
            { key: 'forest', palette: [2, 3, 14, 4], heightScale: 1.3, roughness: 0.4, featureDensity: 0.03 },
            { key: 'snow', palette: [10, 17, 4], heightScale: 1.2, roughness: 0.5, featureDensity: 0.02 },
            { key: 'mountain', palette: [4, 11, 3, 15, 1], heightScale: 10.5, roughness: 0.6, featureDensity: 0.01 },
            { key: 'swamp', palette: [2, 3, 6, 14, 13], heightScale: 0.5, roughness: 0.2, featureDensity: 0.04 },
        ];
        const RECIPES = [
            { id: 'glass', out: { id: 100, count: 4 }, requires: { 5: 2 } },
            { id: 'stained_red', out: { id: 101, count: 2 }, requires: { 100: 1, 12: 1 } },
            { id: 'stained_blue', out: { id: 102, count: 2 }, requires: { 100: 1, 6: 1 } },
            { id: 'stained_green', out: { id: 103, count: 2 }, requires: { 100: 1, 8: 1 } },
            { id: 'stained_yellow', out: { id: 104, count: 2 }, requires: { 100: 1, 5: 1 } },
            { id: 'brick', out: { id: 105, count: 4 }, requires: { 13: 2, 4: 1 } },
            { id: 'smooth_stone', out: { id: 106, count: 4 }, requires: { 4: 4 } },
            { id: 'concrete', out: { id: 107, count: 4 }, requires: { 4: 2, 5: 2 } },
            { id: 'polished_wood', out: { id: 108, count: 2 }, requires: { 7: 2 } },
            { id: 'marble', out: { id: 109, count: 1 }, requires: { 4: 3, 10: 1 } },
            { id: 'obsidian', out: { id: 110, count: 1 }, requires: { 16: 1, 4: 1 } },
            { id: 'crystal_blue', out: { id: 111, count: 1 }, requires: { 100: 1, 6: 1 } },
            { id: 'crystal_purple', out: { id: 112, count: 1 }, requires: { 100: 1, 11: 1 } },
            { id: 'crystal_green', out: { id: 113, count: 1 }, requires: { 100: 1, 8: 1 } },
            { id: 'light_block', out: { id: 114, count: 1 }, requires: { 100: 1, 11: 1 } },
            { id: 'glow_brick', out: { id: 115, count: 1 }, requires: { 105: 1, 11: 1 } },
            { id: 'dark_glass', out: { id: 116, count: 1 }, requires: { 100: 1, 11: 1 } },
            { id: 'glass_tile', out: { id: 117, count: 2 }, requires: { 100: 2 } },
            { id: 'sandstone', out: { id: 118, count: 2 }, requires: { 5: 2 } },
            { id: 'cobblestone', out: { id: 119, count: 4 }, requires: { 4: 4 } },
        ];
        let scene, camera, renderer, controls;
        let meshGroup;
        let chunkManager;
        let raycaster = new THREE.Raycaster();
        let pointer = new THREE.Vector2(0, 0);
        let CHUNK_DELTAS = new Map();
        let worldSeed = 'default@MCWorlds';
        let worldName = 'MyWorld';
        let userName = 'player';
        let userAddress = 'anonymous';
        let player = { x: 0, y: 24, z: 0, vx: 0, vy: 0, vz: 0, onGround: false, health: 20, score: 0, width: 0.6, height: 1.8, yaw: 0, pitch: 0 };
        let spawnPoint = { x: 0, y: 0, z: 0 };
        let lastSavedPosition = new THREE.Vector3(0, 24, 0);
        let selectedBlockId = null;
        let selectedHotIndex = 0;
        let hotbarOffset = 0;
        let cameraMode = 'third';
        let mobs = [];
        let lastDamageTime = 0;
        let lastRegenTime = 0;
        let joystick = { up: false, down: false, left: false, right: false };
        let lastFrame = performance.now();
        let mouseLocked = false;
        let deathScreenShown = false; // Track if death screen is active
        let soundBreak = document.getElementById('soundBreak');
        let soundPlace = document.getElementById('soundPlace');
        let soundJump = document.getElementById('soundJump');
        let soundHit = document.getElementById('soundHit');
        let knownWorlds = new Map();
        let knownUsers = new Map();
        let keywordCache = new Map();
        let profileByURNCache = new Map();
        let profileByAddressCache = new Map();
        let keywordByAddressCache = new Map();
        let addressByKeywordCache = new Map();
        let pending = new Set();
        let spawnChunks = new Map();
        let chunkOwners = new Map();
        let processedMessages = new Set();
        let apiCallTimestamps = [];
        let audioErrorLogged = false;
        let sun, moon, stars, clouds;
        let INVENTORY = new Array(32).fill(null);
        let isPromptOpen = false;
        let userPositions = {};
        async function GetPublicAddressByKeyword(keyword) {
            console.log('%c[API] GetPublicAddressByKeyword called for keyword:', 'color: blue', keyword);
            try {
                if (addressByKeywordCache.has(keyword)) {
                    console.log('%c[Cache Hit] Address for keyword ' + keyword, 'color: green');
                    return addressByKeywordCache.get(keyword);
                }
                console.log('[API Rate Limit] Delayed GetPublicAddressByKeyword:', keyword);
                await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                const response = await fetch(`https://p2fk.io/GetPublicAddressByKeyword/${keyword}?mainnet=false`);
                if (!response.ok) {
                    console.log('%c[API Error] Failed to fetch address for keyword:', 'color: red', keyword, response.status);
                    addMessage('Failed to fetch address for keyword');
                    return null;
                }
                const address = await response.text();
                const cleanAddress = address ? address.trim() : null;
                if (cleanAddress) addressByKeywordCache.set(keyword, cleanAddress);
                console.log('%c[API Success] Got address:', 'color: green', cleanAddress, 'for keyword:', keyword);
                return cleanAddress;
            } catch (e) {
                console.log('%c[API Exception] Error in GetPublicAddressByKeyword:', 'color: red', keyword, e);
                addMessage('Failed to fetch address for keyword');
                return null;
            }
        }
        async function GetPublicMessagesByAddress(address) {
            console.log('%c[API] GetPublicMessagesByAddress called for address:', 'color: blue', address);
            try {
                const cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                console.log('[API Rate Limit] Delayed GetPublicMessagesByAddress:', cleanAddress);
                await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                const response = await fetch(`https://p2fk.io/GetPublicMessagesByAddress/${cleanAddress}?skip=0&qty=5000&mainnet=true`);
                if (!response.ok) {
                    console.log('%c[API Error] Failed to fetch messages for address:', 'color: red', address, response.status);
                    addMessage('Failed to fetch messages: Invalid address');
                    return [];
                }
                const messages = await response.json();
                console.log('%c[API Success] Fetched messages:', 'color: green', messages.length, 'for address:', address);
                return messages;
            } catch (e) {
                console.log('%c[API Exception] Error in GetPublicMessagesByAddress:', 'color: red', address, e);
                addMessage('Failed to fetch messages');
                return [];
            }
        }
        async function GetProfileByURN(urn) {
            console.log('%c[API] GetProfileByURN called for URN:', 'color: blue', urn);
            if (!urn || urn.trim() === '') {
                console.log('%c[API Skip] Invalid empty URN', 'color: orange');
                return null;
            }
            try {
                if (profileByURNCache.has(urn)) {
                    console.log('%c[Cache Hit] Profile for URN ' + urn, 'color: green');
                    return profileByURNCache.get(urn);
                }
                const cleanUrn = encodeURIComponent(urn.trim().replace(/[^a-zA-Z0-9]/g, ''));
                console.log('[API Rate Limit] Delayed GetProfileByURN:', cleanUrn);
                await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                const response = await fetch(`https://p2fk.io/GetProfileByURN/${cleanUrn}?mainnet=false`);
                if (!response.ok) {
                    console.log('%c[API Error] Failed to fetch profile for URN:', 'color: red', urn, response.status);
                    return null;
                }
                const profile = await response.json();
                if (profile) profileByURNCache.set(urn, profile);
                console.log('%c[API Success] Got profile for URN:', 'color: green', urn);
                return profile;
            } catch (e) {
                console.log('%c[API Exception] Error in GetProfileByURN:', 'color: red', urn, e);
                return null;
            }
        }
        async function GetProfileByAddress(address) {
            console.log('%c[API] GetProfileByAddress called for address:', 'color: blue', address);
            try {
                if (profileByAddressCache.has(address)) {
                    console.log('%c[Cache Hit] Profile for address ' + address, 'color: green');
                    return profileByAddressCache.get(address);
                }
                const cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                console.log('[API Rate Limit] Delayed GetProfileByAddress:', cleanAddress);
                await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                const response = await fetch(`https://p2fk.io/GetProfileByAddress/${cleanAddress}?mainnet=false`);
                if (!response.ok) {
                    console.log('%c[API Error] Failed to fetch profile for address:', 'color: red', address, response.status);
                    return null;
                }
                const profile = await response.json();
                if (profile) profileByAddressCache.set(address, profile);
                console.log('%c[API Success] Got profile for address:', 'color: green', address);
                return profile;
            } catch (e) {
                console.log('%c[API Exception] Error in GetProfileByAddress:', 'color: red', address, e);
                return null;
            }
        }
        async function GetKeywordByPublicAddress(address) {
            console.log('%c[API] GetKeywordByPublicAddress called for address:', 'color: blue', address);
            try {
                if (keywordByAddressCache.has(address)) {
                    console.log('%c[Cache Hit] Keyword for address ' + address, 'color: green');
                    return keywordByAddressCache.get(address);
                }
                const cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                console.log('[API Rate Limit] Delayed GetKeywordByPublicAddress:', cleanAddress);
                await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                const response = await fetch(`https://p2fk.io/GetKeywordByPublicAddress/${cleanAddress}?mainnet=false`);
                if (!response.ok) {
                    console.log('%c[API Error] Failed to fetch keyword for address:', 'color: red', address, response.status);
                    addMessage('Failed to fetch keyword for address');
                    return null;
                }
                const keyword = await response.text();
                const cleanKeyword = keyword ? keyword.trim() : null;
                if (cleanKeyword) keywordByAddressCache.set(address, cleanKeyword);
                console.log('%c[API Success] Got keyword:', 'color: green', cleanKeyword, 'for address:', address);
                return cleanKeyword;
            } catch (e) {
                console.log('%c[API Exception] Error in GetKeywordByPublicAddress:', 'color: red', address, e);
                addMessage('Failed to fetch keyword for address');
                return null;
            }
        }
        async function fetchIPFS(hash) {
            console.log('%c[IPFS] Fetching IPFS data for hash:', 'color: blue', hash);
            try {
                console.log('[API Rate Limit] Delayed fetchIPFS:', hash);
                await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                const response = await fetch(`https://ipfs.io/ipfs/${hash}`);
                if (!response.ok) {
                    console.log('%c[IPFS Error] Failed to fetch IPFS data for hash:', 'color: red', hash, response.status);
                    addMessage('Failed to fetch IPFS data');
                    return null;
                }
                const data = await response.json();
                console.log('%c[IPFS Success] Fetched data for hash:', 'color: green', hash);
                return data;
            } catch (e) {
                console.log('%c[IPFS Exception] Error fetching IPFS for hash:', 'color: red', hash, e);
                addMessage('Failed to fetch IPFS data');
                return null;
            }
        }
        async function applySaveFile(data, fromAddress, blockDate) {
            console.log('%c[Apply Save] Processing save file from address:', 'color: blue', fromAddress, 'at:', blockDate);
            if (!data || !data.deltas) {
                console.log('%c[Apply Save Error] Invalid or missing save data from:', 'color: red', fromAddress);
                return;
            }
            const fromProfile = await GetProfileByAddress(fromAddress);
            const username = fromProfile?.URN?.replace(/[^a-zA-Z0-9]/g, '') || 'anonymous';
            const now = Date.now();
            for (const delta of data.deltas) {
                const chunkKey = delta.chunk.replace(/^#/, ''); // Remove # prefix
                const changes = delta.changes;
                const ownership = chunkOwners.get(chunkKey) || { username: '', timestamp: 0, pending: true };
                if (!ownership.username || ownership.username === username || (now - ownership.timestamp >= OWNERSHIP_EXPIRY)) {
                    chunkManager.applyDeltasToChunk(chunkKey, changes);
                    chunkOwners.set(chunkKey, {
                        username,
                        timestamp: new Date(blockDate).getTime(),
                        pending: now - new Date(blockDate).getTime() < PENDING_PERIOD
                    });
                    console.log('%c[Apply Save Success] Applied deltas to chunk:', 'color: green', chunkKey, 'from:', username);
                    addMessage(`Updated chunk ${chunkKey}`, 1000);
                } else {
                    console.log('%c[Apply Save Denied] Chunk owned by:', 'color: orange', ownership.username, 'cannot update from:', username);
                    addMessage(`Cannot edit chunk ${chunkKey}: owned by another user`, 3000);
                }
            }
            if (data.profile && fromAddress === userAddress) {
                lastSavedPosition = new THREE.Vector3(data.profile.x, data.profile.y, data.profile.z);
                INVENTORY = data.profile.inventory || new Array(32).fill(null);
                updateHotbarUI();
                console.log('%c[Apply Save] Updated player position and inventory from:', 'color: green', fromAddress);
            }
        }
        const worker = new Worker(URL.createObjectURL(new Blob([`
                    let profileByURNCache = new Map();
                    let profileByAddressCache = new Map();
                    let keywordByAddressCache = new Map();
                    let addressByKeywordCache = new Map();
                    let processedMessages = new Set();
                    let API_CALLS_PER_SECOND = ${API_CALLS_PER_SECOND};
                    async function fetchData(url) {
                        try {
                            const response = await fetch(url);
                            return response.ok ? await response.json() : null;
                        } catch (e) {
                            console.log('[Worker Error] Fetch data failed:', url, e);
                            return null;
                        }
                    }
                    async function fetchText(url) {
                        try {
                            const response = await fetch(url);
                            return response.ok ? await response.text() : null;
                        } catch (e) {
                            console.log('[Worker Error] Fetch text failed:', url, e);
                            return null;
                        }
                    }
                    async function getPublicAddressByKeyword(keyword) {
                console.log('%c[API] getPublicAddressByKeyword called for keyword:', 'color: blue', keyword);
                try {
                    if (addressByKeywordCache.has(keyword)) {
                        console.log('%c[Cache Hit] Address for keyword ' + keyword, 'color: green');
                        return addressByKeywordCache.get(keyword);
                    }

                    console.log('[API Rate Limit] Delayed getPublicAddressByKeyword:', keyword);
                    await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));

                    const response = await fetch('https://p2fk.io/GetPublicAddressByKeyword/' + keyword+ '?mainnet=false');
                    if (!response.ok) {
                        console.log('%c[API Error] Failed to fetch address for keyword:', 'color: red', keyword, response.status);
                        addMessage('Failed to fetch address for keyword');
                        return null;
                    }

                    const address = await response.text();
                    // Clean up: remove all quotes and trim whitespace
                    const cleanAddress = address ? address.replace(/["']/g, '').trim() : null;
                    if (cleanAddress) addressByKeywordCache.set(keyword, cleanAddress);

                    console.log('%c[API Success] Got address:', 'color: green', cleanAddress, 'for keyword:', keyword);
                    return cleanAddress;
                } catch (e) {
                    console.log('%c[API Exception] Error in GetPublicAddressByKeyword:', 'color: red', keyword, e);
                    addMessage('Failed to fetch address for keyword');
                    return null;
                }
            }
                    async function getPublicMessagesByAddress(address) {
                        console.log('%c[API] getPublicMessagesByAddress called for address:', 'color: blue', address);
                        try {
                            const cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                            console.log('[API Rate Limit] Delayed getPublicMessagesByAddress:', cleanAddress);
                            await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                            const response = await fetch('https://p2fk.io/GetPublicMessagesByAddress/' + cleanAddress + '?skip=0&qty=5000&mainnet=false');
                            if (!response.ok) {
                                console.log('%c[API Error] Failed to fetch messages for address:', 'color: red', address, response.status);
                                return [];
                            }
                            const messages = await response.json();
                            console.log('%c[API Success] Fetched messages:', 'color: green', messages.length, 'for address:', address);
                            return messages;
                        } catch (e) {
                            console.log('%c[API Exception] Error in getPublicMessagesByAddress:', 'color: red', address, e);
                            return [];
                        }
                    }
                    async function getProfileByURN(urn) {
                        console.log('%c[API] getProfileByURN called for URN:', 'color: blue', urn);
                        if (!urn || urn.trim() === '') {
                            console.log('%c[API Skip] Invalid empty URN', 'color: orange');
                            return null;
                        }
                        try {
                            if (profileByURNCache.has(urn)) {
                                console.log('%c[Cache Hit] Profile for URN ' + urn, 'color: green');
                                return profileByURNCache.get(urn);
                            }
                            const cleanUrn = encodeURIComponent(urn.trim().replace(/[^a-zA-Z0-9]/g, ''));
                            console.log('[API Rate Limit] Delayed getProfileByURN:', cleanUrn);
                            await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                            const response = await fetch('https://p2fk.io/GetProfileByURN/' + cleanUrn + '?mainnet=false');
                            if (!response.ok) {
                                console.log('%c[API Error] Failed to fetch profile for URN:', 'color: red', urn, response.status);
                                return null;
                            }
                            const profile = await response.json();
                            if (profile) profileByURNCache.set(urn, profile);
                            console.log('%c[API Success] Got profile for URN:', 'color: green', urn);
                            return profile;
                        } catch (e) {
                            console.log('%c[API Exception] Error in getProfileByURN:', 'color: red', urn, e);
                            return null;
                        }
                    }
                    async function getProfileByAddress(address) {
                        console.log('%c[API] getProfileByAddress called for address:', 'color: blue', address);
                        try {
                            if (profileByAddressCache.has(address)) {
                                console.log('%c[Cache Hit] Profile for address ' + address, 'color: green');
                                return profileByAddressCache.get(address);
                            }
                            const cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                            console.log('[API Rate Limit] Delayed getProfileByAddress:', cleanAddress);
                            await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                            const response = await fetch('https://p2fk.io/GetProfileByAddress/' + cleanAddress + '?mainnet=false');
                            if (!response.ok) {
                                console.log('%c[API Error] Failed to fetch profile for address:', 'color: red', address, response.status);
                                return null;
                            }
                            const profile = await response.json();
                            if (profile) profileByAddressCache.set(address, profile);
                            console.log('%c[API Success] Got profile for address:', 'color: green', address);
                            return profile;
                        } catch (e) {
                            console.log('%c[API Exception] Error in getProfileByAddress:', 'color: red', address, e);
                            return null;
                        }
                    }
                    async function getKeywordByPublicAddress(address) {
                        console.log('%c[API] getKeywordByPublicAddress called for address:', 'color: blue', address);
                        try {
                            if (keywordByAddressCache.has(address)) {
                                console.log('%c[Cache Hit] Keyword for address ' + address, 'color: green');
                                return keywordByAddressCache.get(address);
                            }
                            const cleanAddress = encodeURIComponent(address.trim().replace(/[^a-zA-Z0-9]/g, ''));
                            console.log('[API Rate Limit] Delayed getKeywordByPublicAddress:', cleanAddress);
                            await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                            const response = await fetch('https://p2fk.io/GetKeywordByPublicAddress/' + cleanAddress + '?mainnet=false');
                            if (!response.ok) {
                                console.log('%c[API Error] Failed to fetch keyword for address:', 'color: red', address, response.status);
                                return null;
                            }
                            const keyword = await response.text();
                            const cleanKeyword = keyword ? keyword.trim() : null;
                            if (cleanKeyword) keywordByAddressCache.set(address, cleanKeyword);
                            console.log('%c[API Success] Got keyword:', 'color: green', cleanKeyword, 'for address:', address);
                            return cleanKeyword;
                        } catch (e) {
                            console.log('%c[API Exception] Error in getKeywordByPublicAddress:', 'color: red', address, e);
                            return null;
                        }
                    }
                    async function fetchIPFS(hash) {
                        console.log('%c[IPFS] Fetching IPFS data for hash:', 'color: blue', hash);
                        try {
                            console.log('[API Rate Limit] Delayed fetchIPFS:', hash);
                            await new Promise(r => setTimeout(r, 1000 / API_CALLS_PER_SECOND));
                            const response = await fetch('https://ipfs.io/ipfs/' + hash);
                            if (!response.ok) {
                                console.log('%c[IPFS Error] Failed to fetch IPFS data for hash:', 'color: red', hash, response.status);
                                return null;
                            }
                            const data = await response.json();
                            console.log('%c[IPFS Success] Fetched data for hash:', 'color: green', hash);
                            return data;
                        } catch (e) {
                            console.log('%c[IPFS Exception] Error fetching IPFS for hash:', 'color: red', hash, e);
                            return null;
                        }
                    }
                    self.onmessage = async function(e) {
                        const { type, chunkKeys, masterKey, userAddress, worldName } = e.data;
                        console.log('[Worker] Received message type:', type);
                        if (type === 'poll') {
                            try {
                                console.log('[Worker] Polling master key:', masterKey);
                                const masterAddr = await getPublicAddressByKeyword(masterKey);
                                if (masterAddr) {
                                    const cleanMasterAddr = encodeURIComponent(masterAddr.trim().replace(/[^a-zA-Z0-9]/g, ''));
                                    const messages = await getPublicMessagesByAddress(cleanMasterAddr);
                                    const worlds = new Map();
                                    const users = new Map();
                                    const joinData = [];
                                    for (const msg of messages || []) {
                                        if (msg.TransactionId && !processedMessages.has(msg.TransactionId)) {
                                            console.log('[Worker] Processing master message:', msg.TransactionId);
                                            const fromProfile = await getProfileByAddress(msg.FromAddress);
                                            if (!fromProfile || !fromProfile.URN) {
                                                console.log('[Worker] Invalid fromProfile for msg:', msg.TransactionId);
                                                continue;
                                            }
                                            const user = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '');
                                            const userProfile = await getProfileByURN(user);
                                            if (!userProfile || !userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) {
                                                console.log('[Worker] Invalid userProfile for msg:', msg.TransactionId);
                                                continue;
                                            }
                                            const toKeywordRaw = await getKeywordByPublicAddress(msg.ToAddress);
                                            if (!toKeywordRaw) {
                                                console.log('[Worker] No toKeyword for msg:', msg.TransactionId);
                                                continue;
                                            }
                                            const toKeyword = toKeywordRaw.replace(/^"|"$/g, '');
                                            if (!toKeyword.includes('MCUserJoin@')) {
                                                console.log('[Worker] Invalid toKeyword for msg:', msg.TransactionId);
                                                continue;
                                            }
                                            const world = toKeyword.split('@')[1].replace(/[^a-zA-Z0-9]/g, '');
                                            if (user && world) {
                                                console.log('[Worker] Found join data for user:', user, 'world:', world);
                                                if (!worlds.has(world)) worlds.set(world, msg.ToAddress);
                                                if (!users.has(user)) users.set(user, msg.FromAddress);
                                                joinData.push({ user, world, username: user, transactionId: msg.TransactionId });
                                            }
                                        }
                                    }
                                    console.log('[Worker] Posting worlds_users data:', worlds.size, 'worlds,', users.size, 'users');
                                    self.postMessage({ type: 'worlds_users', worlds: Object.fromEntries(worlds), users: Object.fromEntries(users), joinData });
                                } else {
                                    console.log('[Worker] No master address for key:', masterKey);
                                }
                            } catch (e) {
                                console.log('[Worker Exception] Error in master poll:', e);
                            }
                            const updatesByTransaction = new Map();
                            const ownershipByChunk = new Map();
                            for (const chunkKey of chunkKeys) {
                                try {
                                    const normalizedChunkKey = chunkKey.replace(/^#/, '');
                                    console.log('[Worker] Polling chunk:', normalizedChunkKey);
                                    const addr = await getPublicAddressByKeyword(normalizedChunkKey);
                                    if (!addr) {
                                        console.log('[Worker] No address for chunk:', normalizedChunkKey);
                                        continue;
                                    }
                                    const messages = await getPublicMessagesByAddress(addr);
                                    for (const msg of messages || []) {
                                        if (msg.TransactionId && !processedMessages.has(msg.TransactionId)) {
                                            console.log('[Worker] Processing chunk message:', msg.TransactionId, 'for chunk:', normalizedChunkKey);
                                            const match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                                            if (match) {
                                                const hash = match[1];
                                                const cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                                                if (!cidRegex.test(hash)) {
                                                    console.log('[Worker] Invalid CID in message for chunk:', normalizedChunkKey, 'CID:', hash);
                                                    continue;
                                                }
                                                if (!updatesByTransaction.has(msg.TransactionId)) {
                                                    const data = await fetchIPFS(hash);
                                                    if (data?.deltas) {
                                                        console.log('[Worker] Valid deltas found for transaction:', msg.TransactionId, 'hash:', hash);
                                                        const normalizedDeltas = data.deltas.map(delta => ({
                                                            ...delta,
                                                            chunk: delta.chunk.replace(/^#/, '')
                                                        }));
                                                        updatesByTransaction.set(msg.TransactionId, {
                                                            changes: normalizedDeltas,
                                                            address: msg.FromAddress,
                                                            timestamp: new Date(msg.BlockDate).getTime(),
                                                            transactionId: msg.TransactionId
                                                        });
                                                        for (const delta of normalizedDeltas) {
                                                            const chunk = delta.chunk;
                                                            if (!ownershipByChunk.has(chunk)) {
                                                                const fromProfile = await getProfileByAddress(msg.FromAddress);
                                                                if (fromProfile && fromProfile.URN) {
                                                                    const username = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '');
                                                                    ownershipByChunk.set(chunk, {
                                                                        chunkKey: chunk,
                                                                        username,
                                                                        timestamp: new Date(msg.BlockDate).getTime()
                                                                    });
                                                                    console.log('[Worker] Updated ownership for chunk:', chunk, 'user:', username);
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        console.log('[Worker] No valid deltas in IPFS data for hash:', hash);
                                                    }
                                                } else {
                                                    console.log('[Worker] Skipping already processed transaction:', msg.TransactionId, 'for chunk:', normalizedChunkKey);
                                                }
                                            } else {
                                                console.log('[Worker] No IPFS match in message:', msg.TransactionId);
                                            }
                                        } else {
                                            console.log('[Worker] Skipping processed message:', msg.TransactionId);
                                        }
                                    }
                                } catch (e) {
                                    console.log('[Worker Exception] Error processing chunk:', normalizedChunkKey, e);
                                }
                            }
                            if (updatesByTransaction.size > 0) {
                                for (const [transactionId, update] of updatesByTransaction) {
                                    console.log('[Worker] Posting chunk updates for transaction:', transactionId, 'chunks:', update.changes.length);
                                    self.postMessage({ type: 'chunk_updates', updates: [{
                                        changes: update.changes,
                                        address: update.address,
                                        timestamp: update.timestamp,
                                        transactionId: update.transactionId
                                    }] });
                                }
                            }
                            if (ownershipByChunk.size > 0) {
                                for (const ownership of ownershipByChunk.values()) {
                                    console.log('[Worker] Posting chunk ownership for:', ownership.chunkKey, 'username:', ownership.username);
                                    self.postMessage({ type: 'chunk_ownership', chunkKey: ownership.chunkKey, username: ownership.username, timestamp: ownership.timestamp });
                                }
                            }
                            try {
                                const joinKeyword = userAddress === 'anonymous' ? \`${worldName}\` : userAddress;
                                console.log('[Worker] Polling user join data for:', joinKeyword);
                                const addressRes = await getPublicAddressByKeyword(joinKeyword);
                                if (addressRes) {
                                    const messages = await getPublicMessagesByAddress(addressRes);
                                    for (const msg of messages || []) {
                                        if (msg.FromAddress === userAddress && !processedMessages.has(msg.TransactionId)) {
                                            console.log('[Worker] Processing user message:', msg.TransactionId);
                                            const match = msg.Message.match(/IPFS:([a-zA-Z0-9]+)/);
                                            if (match) {
                                                const hash = match[1];
                                                const cidRegex = /^[A-Za-z0-9]{46}$|^[A-Za-z0-9]{59}$|^[a-z0-9]+$/;
                                                if (!cidRegex.test(hash)) {
                                                    console.log('[Worker] Invalid CID in user message:', hash);
                                                    continue;
                                                }
                                                const data = await fetchIPFS(hash);
                                                if (data) {
                                                    console.log('[Worker] Posting user update for:', userAddress, 'hash:', hash);
                                                    self.postMessage({ type: 'user_update', data, address: msg.FromAddress, timestamp: new Date(msg.BlockDate).getTime(), transactionId: msg.TransactionId });
                                                } else {
                                                    console.log('[Worker] No valid data for IPFS hash:', hash);
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                console.log('[Worker Exception] Error polling user join data:', e);
                            }
                        } else if (type === 'update_processed') {
                            console.log('[Worker] Updating processed messages:', e.data.transactionIds.length);
                            e.data.transactionIds.forEach(id => processedMessages.add(id));
                        } else if (type === 'retry_chunk') {
                            console.log('[Worker] Retrying poll for chunk:', e.data.chunkKey);
                            self.postMessage({ type: 'poll', chunkKeys: [e.data.chunkKey], masterKey, userAddress, worldName });
                        } else if (type === 'cleanup_pending') {
                            console.log('[Worker] Cleaning up pending keys:', e.data.pendingKeys.length);
                            const { pcx, pcz, pendingKeys, chunksPerSide, pollRadius } = e.data;
                            const keysToDelete = [];
                            for (const key of pendingKeys) {
                                const match = key.match(/^([A-Z]{1,8}):(\d{1,5}):(\d{1,5})$/);
                                if (match) {
                                    const cx = parseInt(match[2]);
                                    const cz = parseInt(match[3]);
                                    const dx = Math.min(Math.abs(cx - pcx), chunksPerSide - Math.abs(cx - pcx));
                                    const dz = Math.min(Math.abs(cz - pcz), chunksPerSide - Math.abs(cz - pcz));
                                    if (dx > pollRadius || dz > pollRadius) {
                                        keysToDelete.push(key);
                                    }
                                }
                            }
                            console.log('[Worker] Deleting pending keys:', keysToDelete.length);
                            self.postMessage({ type: 'cleanup_pending', keysToDelete });
                        }
                    };
`], { type: 'application/javascript' })));
        worker.onmessage = e => {
            if (e.data.type === 'worlds_users') {
                worlds = e.data.worlds;
                users = e.data.users;
                joinData = e.data.joinData;
                console.log('[Main] Received worlds_users data:', Object.keys(worlds).length, 'worlds,', Object.keys(users).length, 'users');
            } else if (e.data.type === 'chunk_updates') {
                for (const update of e.data.updates) {
                    for (const delta of update.changes) {
                        const normalizedKey = delta.chunk.replace(/^#/, '');
                        const parsed = parseChunkKey(normalizedKey);
                        if (!parsed) {
                            console.log('[Main] Invalid JSON chunk key:', delta.chunk);
                            continue;
                        }
                        const chunk = chunkManager.getChunk(parsed.cx, parsed.cz);
                        if (chunk && chunk.key === normalizedKey) {
                            console.log('[Main] Applying deltas to chunk:', normalizedKey, 'changes:', delta.changes.length);
                            chunkManager.applyDeltasToChunk(normalizedKey, delta.changes);
                            chunkManager.markDirty(normalizedKey);
                            console.log('[Worker Message] Applied deltas to chunk:', normalizedKey);
                        } else {
                            console.log('[Main] Chunk not found or mismatch:', normalizedKey, 'expected cx:', parsed.cx, 'cz:', parsed.cz);
                        }
                    }
                    worker.postMessage({ type: 'update_processed', transactionIds: [update.transactionId] });
                }
            } else if (e.data.type === 'chunk_ownership') {
                console.log('[Main] Received chunk ownership:', e.data.chunkKey, 'username:', e.data.username);
                updateChunkOwnership(e.data.chunkKey, e.data.username, e.data.timestamp);
            } else if (e.data.type === 'user_update') {
                console.log('[Main] Received user update for:', e.data.address);
                if (e.data.data.profile) {
                    const pos = e.data.data.profile;
                    if (pos.x !== undefined && pos.y !== undefined && pos.z !== undefined) {
                        userPositions[e.data.address] = pos;
                        console.log('[Main] Updated user position:', e.data.address, pos);
                    }
                }
                worker.postMessage({ type: 'update_processed', transactionIds: [e.data.transactionId] });
            } else if (e.data.type === 'cleanup_pending') {
                console.log('[Main] Cleaning up pending keys:', e.data.keysToDelete.length);
                for (const key of e.data.keysToDelete) {
                    pending.delete(key);
                }
            }
        };
        function startWorker() {
            console.log('%c[Main] Starting worker poll interval', 'color: cyan');
            setInterval(() => {
                if (isPromptOpen) {
                    console.log('%c[Main] Poll skipped, prompt open', 'color: cyan');
                    return;
                }
                const pcx = Math.floor(modWrap(player.x, MAP_SIZE) / CHUNK_SIZE);
                const pcz = Math.floor(modWrap(player.z, MAP_SIZE) / CHUNK_SIZE);
                console.log('%c[Poll] Player chunk position:', 'color: cyan', pcx, pcz);
                const chunkKeys = Array.from(chunkManager?.chunks?.keys() || []);
                const filteredKeys = chunkKeys.filter(key => {
                    const parsed = parseChunkKey(key);
                    if (!parsed) return false;
                    const dx = Math.min(Math.abs(parsed.cx - pcx), CHUNKS_PER_SIDE - Math.abs(parsed.cx - pcx));
                    const dz = Math.min(Math.abs(parsed.cz - pcz), CHUNKS_PER_SIDE - Math.abs(parsed.cz - pcz));
                    return dx <= POLL_RADIUS && dz <= POLL_RADIUS;
                });
                console.log('%c[Poll] Sending poll for chunks in radius:', 'color: cyan', filteredKeys.length, filteredKeys);
                worker.postMessage({ type: 'poll', chunkKeys: filteredKeys, masterKey: MASTER_WORLD_KEY, userAddress, worldName });
            }, POLL_INTERVAL);
        }
        function checkChunkOwnership(chunkKey, username) {
            const normalizedKey = chunkKey.replace(/^#/, '');
            console.log('%c[Main] Checking ownership for chunk:', 'color: blue', normalizedKey, 'username:', username);
            if (spawnChunks.size > 0) {
                for (const [user, spawn] of spawnChunks) {
                    const parsed = parseChunkKey(normalizedKey);
                    if (!parsed) return false;
                    if (spawn.cx === parsed.cx && spawn.cz === parsed.cz && user !== username) {
                        console.log('%c[Main] Ownership denied - spawn chunk mismatch', 'color: orange');
                        return false;
                    }
                }
            }
            const ownership = chunkOwners.get(normalizedKey);
            if (!ownership) {
                console.log('%c[Main] No existing ownership for chunk:', 'color: green', normalizedKey);
                return true;
            }
            const now = Date.now();
            if (now - ownership.timestamp > OWNERSHIP_EXPIRY) {
                console.log('%c[Main] Ownership expired for chunk:', 'color: green', normalizedKey);
                return true;
            }
            if (ownership.pending && now - ownership.timestamp < PENDING_PERIOD) {
                console.log('%c[Main] Pending period for chunk:', 'color: green', normalizedKey);
                return true;
            }
            const allowed = ownership.username === username;
            console.log('%c[Main] Ownership check result:', 'color: blue', allowed, 'for chunk:', normalizedKey, 'ownership.username:', ownership.username, 'userName:', username);
            return allowed;
        }
        function updateChunkOwnership(chunkKey, username, timestamp) {
            const normalizedKey = chunkKey.replace(/^#/, '');
            console.log('%c[Main] Updating ownership for chunk:', 'color: blue', normalizedKey, 'username:', username, 'timestamp:', timestamp);
            const now = Date.now();
            const ownership = chunkOwners.get(normalizedKey);
            if (!ownership) {
                chunkOwners.set(normalizedKey, { username, timestamp, pending: true });
            } else {
                if (now - ownership.timestamp < PENDING_PERIOD) {
                    ownership.username = username;
                    ownership.timestamp = timestamp;
                } else {
                    ownership.pending = false;
                    ownership.username = username;
                    ownership.timestamp = timestamp;
                }
            }
        }
        function makeSeededRandom(seed) {
            let h = 2166136261 >>> 0;
            for (let i = 0; i < seed.length; i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
            return function () {
                h += 0x6D2B79F5; let t = Math.imul(h ^ (h >>> 15), 1 | h);
                t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            };
        }
        function makeNoise(seed) {
            const rnd = makeSeededRandom(seed);
            const cache = {};
            function corner(ix, iy) {
                const k = ix + ',' + iy;
                if (cache[k] !== undefined) return cache[k];
                const s = seed + '|' + ix + ',' + iy;
                const r = makeSeededRandom(s)();
                return cache[k] = r;
            }
            function interp(a, b, t) { return a + (b - a) * (t * (t * (3 - 2 * t))); }
            return function (x, y) {
                const ix = Math.floor(x), iy = Math.floor(y);
                const fx = x - ix, fy = y - iy;
                const a = corner(ix, iy), b = corner(ix + 1, iy), c = corner(ix, iy + 1), d = corner(ix + 1, iy + 1);
                const ab = interp(a, b, fx), cd = interp(c, d, fx);
                return interp(ab, cd, fy);
            };
        }
        function fbm(noiseFn, x, y, oct = 4, persistence = 0.5) {
            let sum = 0, amp = 1, freq = 1, max = 0;
            for (let i = 0; i < oct; i++) { sum += amp * noiseFn(x * freq, y * freq); max += amp; amp *= persistence; freq *= 2; }
            return sum / max;
        }
        function modWrap(n, m) {
            return ((n % m) + m) % m;
        }
        function makeChunkKey(world, cx, cz) {
            const clean = ('' + world).replace(/[^a-zA-Z0-9]/g, '').slice(0, 8);
            return `${clean}:${cx}:${cz}`;
        }
        function parseJsonChunkKey(key) {
            const match = key.match(/^#?([A-Z]{1,8}):(\d{1,5}):(\d{1,5})$/);
            if (match) {
                return {
                    world: match[1],
                    cx: parseInt(match[2]),
                    cz: parseInt(match[3])
                };
            }
            console.log('%c[Parse Error] Invalid JSON chunk key:', 'color: red', key);
            return null;
        }
        function parseChunkKey(key) {
            const match = key.match(/^([A-Z]{1,8}):(\d{1,5}):(\d{1,5})$/);
            if (match) {
                return {
                    world: match[1],
                    cx: parseInt(match[2]),
                    cz: parseInt(match[3])
                };
            }
            console.log('%c[Parse Error] Invalid internal chunk key:', 'color: red', key);
            return null;
        }
        function hashSeed(seed) {
            let h = 2166136261 >>> 0;
            for (let i = 0; i < seed.length; i++) h = Math.imul(h ^ seed.charCodeAt(i), 16777619) >>> 0;
            return h % MAP_SIZE;
        }
        function calculateSpawnPoint(seed) {
            const rnd = makeSeededRandom(seed);
            const x = Math.floor(rnd() * MAP_SIZE);
            const z = Math.floor(rnd() * MAP_SIZE);
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const chunk = chunkManager.getChunk(cx, cz);
            if (!chunk.generated) chunkManager.generateChunk(chunk);
            let y = MAX_HEIGHT - 1;
            while (y > 0 && chunk.get(x % CHUNK_SIZE, y, z % CHUNK_SIZE) === BLOCK_AIR) y--;
            y += 2;
            return { x, y, z };
        }
        function initSky() {
            sun = new THREE.Mesh(
                new THREE.SphereGeometry(10, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xffff00 })
            );
            moon = new THREE.Mesh(
                new THREE.SphereGeometry(8, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xcccccc })
            );
            stars = new THREE.Group();
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            const starNoise = makeNoise(worldSeed + '_stars');
            for (let i = 0; i < 1000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = 1000 * Math.sin(phi) * Math.cos(theta);
                const y = 1000 * Math.sin(phi) * Math.sin(theta);
                const z = 1000 * Math.cos(phi);
                if (starNoise(x * 0.01, z * 0.01) > 0.7) {
                    starVertices.push(x, y, z);
                }
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            const starPoints = new THREE.Points(starGeometry, starMaterial);
            stars.add(starPoints);
            clouds = new THREE.Group();
            for (let i = 0; i < 20; i++) {
                const cloud = new THREE.Mesh(
                    new THREE.PlaneGeometry(50, 50),
                    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
                );
                cloud.position.set(
                    (Math.random() - 0.5) * 2000,
                    100 + Math.random() * 50,
                    (Math.random() - 0.5) * 2000
                );
                clouds.add(cloud);
            }
            scene.add(sun, moon, stars, clouds);
        }
        function updateSky(dt) {
            const now = new Date();
            const hours = now.getHours() + now.getMinutes() / 60;
            const t = (hours / 24) * Math.PI * 2;
            const isNight = hours >= 18 || hours < 6;
            const sunAngle = t;
            const moonAngle = t + Math.PI;
            sun.position.set(1000 * Math.cos(sunAngle), 1000 * Math.sin(sunAngle), 0);
            moon.position.set(1000 * Math.cos(moonAngle), 1000 * Math.sin(moonAngle), 0);
            stars.visible = isNight;
            clouds.children.forEach(cloud => {
                cloud.position.x = modWrap(cloud.position.x + dt * 10, 2000);
                cloud.lookAt(camera.position);
            });
            const dayColor = new THREE.Color(0x87ceeb);
            const nightColor = new THREE.Color(0x1c2526);
            const tNorm = Math.sin(t) * 0.5 + 0.5;
            scene.background = dayColor.lerp(nightColor, tNorm);
            const ambientLight = scene.getObjectByProperty('type', 'AmbientLight');
            ambientLight.intensity = isNight ? 0.2 : 0.45;
            sun.visible = !isNight;
            moon.visible = isNight;
        }
        class Chunk {
            constructor(cx, cz) {
                this.cx = cx; this.cz = cz;
                this.key = makeChunkKey(worldName, cx, cz);
                this.data = new Uint8Array(CHUNK_SIZE * MAX_HEIGHT * CHUNK_SIZE);
                this.mesh = null;
                this.generated = false;
                this.needsRebuild = true;
            }
            idx(x, y, z) { return (y * CHUNK_SIZE + z) * CHUNK_SIZE + x; }
            get(x, y, z) { if (x < 0 || x >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE || y < 0 || y >= MAX_HEIGHT) return BLOCK_AIR; return this.data[this.idx(x, y, z)]; }
            set(x, y, z, v) { if (x < 0 || x >= CHUNK_SIZE || z < 0 || z >= CHUNK_SIZE || y < 0 || y >= MAX_HEIGHT) return; this.data[this.idx(x, y, z)] = v; this.needsRebuild = true; }
        }
        class ChunkManager {
            constructor(seed) {
                this.seed = seed;
                this.noise = makeNoise(seed);
                this.blockNoise = makeNoise(seed + '_block');
                this.chunks = new Map();
                this.lastPcx = null;
                this.lastPcz = null;
                meshGroup = new THREE.Group(); scene.add(meshGroup);
            }
            getChunk(cx, cz) {
                const chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
                const wrappedCx = modWrap(cx, chunksPerSide);
                const wrappedCz = modWrap(cz, chunksPerSide);
                const key = makeChunkKey(worldName, wrappedCx, wrappedCz);
                if (this.chunks.has(key)) return this.chunks.get(key);
                const c = new Chunk(wrappedCx, wrappedCz);
                this.chunks.set(c.key, c);
                pending.add(c.key);
                return c;
            }
            generateChunk(chunk) {
                if (chunk.generated) return;
                const baseX = chunk.cx * CHUNK_SIZE;
                const baseZ = chunk.cz * CHUNK_SIZE;
                for (let lx = 0; lx < CHUNK_SIZE; lx++) {
                    for (let lz = 0; lz < CHUNK_SIZE; lz++) {
                        const wx = baseX + lx;
                        const wz = baseZ + lz;
                        const nx = (wx % MAP_SIZE) / MAP_SIZE * 10000;
                        const nz = (wz % MAP_SIZE) / MAP_SIZE * 10000;
                        const n = fbm(this.noise, nx * 0.005, nz * 0.005, 5, 0.6);
                        const biome = this.pickBiome(n);
                        const heightScale = biome.heightScale;
                        const roughness = biome.roughness;
                        let height = Math.floor(n * 40 * heightScale + 8);
                        if (n > 0.7) height += Math.floor((n - 0.7) * 60 * heightScale);
                        const localN = fbm(this.noise, nx * 0.05, nz * 0.05, 4, 0.5);
                        height += Math.floor(localN * 15 * roughness);
                        height = Math.max(1, Math.min(MAX_HEIGHT - 1, height));
                        for (let y = 0; y <= height; y++) {
                            let id = BLOCK_AIR;
                            if (y === 0) id = 1;
                            else if (y < height - 3) id = 4;
                            else if (y < height) id = 3;
                            else {
                                const blockN = fbm(this.blockNoise, nx * 0.1, nz * 0.1, 3, 0.6);
                                const paletteIndex = Math.floor(blockN * biome.palette.length);
                                id = biome.palette[paletteIndex % biome.palette.length];
                            }
                            chunk.set(lx, y, lz, id);
                        }
                        for (let y = height + 1; y <= SEA_LEVEL; y++) chunk.set(lx, y, lz, 6);
                        if (biome.key === 'forest' && Math.random() < biome.featureDensity) this.placeTree(chunk, lx, height + 1, lz);
                        else if (biome.key === 'plains' && Math.random() < biome.featureDensity) this.placeFlower(chunk, lx, height + 1, lz);
                        else if (biome.key === 'desert' && Math.random() < biome.featureDensity) this.placeCactus(chunk, lx, height + 1, lz);
                    }
                }
                chunk.generated = true; chunk.needsRebuild = true;
            }
            pickBiome(n) {
                if (n > 0.68) return BIOMES.find(b => b.key === 'snow') || BIOMES[0];
                if (n < 0.25) return BIOMES.find(b => b.key === 'desert') || BIOMES[1];
                if (n > 0.45) return BIOMES.find(b => b.key === 'forest') || BIOMES[2];
                if (n > 0.60) return BIOMES.find(b => b.key === 'mountain') || BIOMES[4];
                if (n < 0.35) return BIOMES.find(b => b.key === 'swamp') || BIOMES[5];
                return BIOMES.find(b => b.key === 'plains') || BIOMES[0];
            }
            placeTree(chunk, lx, cy, lz) {
                const h = 5 + Math.floor(Math.random() * 3);
                for (let i = 0; i < h; i++) if (cy + i < MAX_HEIGHT) chunk.set(lx, cy + i, lz, 7);
                for (let dx = -2; dx <= 2; dx++) for (let dz = -2; dz <= 2; dz++) for (let dy = 0; dy <= 3; dy++) {
                    const rx = lx + dx, ry = cy + h - 2 + dy, rz = lz + dz;
                    if (ry < MAX_HEIGHT && rx >= 0 && rx < CHUNK_SIZE && rz >= 0 && rz < CHUNK_SIZE) {
                        if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy) <= 4 && chunk.get(rx, ry, rz) === BLOCK_AIR) chunk.set(rx, ry, rz, 8);
                    }
                }
            }
            placeFlower(chunk, lx, cy, lz) { if (cy < MAX_HEIGHT && chunk.get(lx, cy, lz) === BLOCK_AIR) chunk.set(lx, cy, lz, 12); }
            placeCactus(chunk, lx, cy, lz) { const h = 1 + Math.floor(Math.random() * 3); for (let i = 0; i < h; i++) if (cy + i < MAX_HEIGHT) chunk.set(lx, cy + i, lz, 9); }
            buildChunkMesh(chunk) {
                if (chunk.mesh) { meshGroup.remove(chunk.mesh); disposeObject(chunk.mesh); chunk.mesh = null; }
                const lists = {};
                const baseX = chunk.cx * CHUNK_SIZE;
                const baseZ = chunk.cz * CHUNK_SIZE;
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        for (let y = 0; y < MAX_HEIGHT; y++) {
                            const id = chunk.get(x, y, z);
                            if (!id || id === BLOCK_AIR) continue;
                            const wx = modWrap(baseX + x, MAP_SIZE);
                            const wz = modWrap(baseZ + z, MAP_SIZE);
                            const exposed = (
                                this.getBlockGlobal(chunk.cx, chunk.cz, x + 1, y, z) === BLOCK_AIR ||
                                this.getBlockGlobal(chunk.cx, chunk.cz, x - 1, y, z) === BLOCK_AIR ||
                                this.getBlockGlobal(chunk.cx, chunk.cz, x, y + 1, z) === BLOCK_AIR ||
                                this.getBlockGlobal(chunk.cx, chunk.cz, x, y - 1, z) === BLOCK_AIR ||
                                this.getBlockGlobal(chunk.cx, chunk.cz, x, y, z + 1) === BLOCK_AIR ||
                                this.getBlockGlobal(chunk.cx, chunk.cz, x, y, z - 1) === BLOCK_AIR
                            );
                            if (!exposed) continue;
                            if (!lists[id]) lists[id] = [];
                            lists[id].push({ x: wx, y: y, z: wz });
                        }
                    }
                }
                const group = new THREE.Group();
                for (const idStr in lists) {
                    const arr = lists[idStr];
                    if (!arr || arr.length === 0) continue;
                    const id = parseInt(idStr);
                    const box = new THREE.BoxGeometry(1, 1, 1);
                    const positions = []; const normals = []; const uvs = []; const indices = []; let vertOffset = 0;
                    for (const p of arr) {
                        const posAttr = box.attributes.position.array;
                        const normAttr = box.attributes.normal.array;
                        const uvAttr = box.attributes.uv.array;
                        const idxAttr = box.index.array;
                        for (let vi = 0; vi < box.attributes.position.count; vi++) {
                            positions.push(posAttr[vi * 3 + 0] + p.x, posAttr[vi * 3 + 1] + p.y, posAttr[vi * 3 + 2] + p.z);
                            normals.push(normAttr[vi * 3 + 0], normAttr[vi * 3 + 1], normAttr[vi * 3 + 2]);
                            uvs.push(uvAttr[vi * 2 + 0], uvAttr[vi * 2 + 1]);
                        }
                        for (let ii = 0; ii < idxAttr.length; ii++) indices.push(idxAttr[ii] + vertOffset);
                        vertOffset += box.attributes.position.count;
                    }
                    const geom = new THREE.BufferGeometry();
                    geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                    geom.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                    geom.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
                    geom.setIndex(indices);
                    geom.computeBoundingSphere();
                    const info = BLOCKS[id] || { color: '#ff00ff' };
                    const mat = info.transparent ?
                        new THREE.MeshBasicMaterial({ color: new THREE.Color(info.color), transparent: true, opacity: 0.6, side: THREE.DoubleSide }) :
                        new THREE.MeshLambertMaterial({ color: new THREE.Color(info.color) });
                    const mesh = new THREE.Mesh(geom, mat);
                    group.add(mesh);
                }
                chunk.mesh = group; meshGroup.add(chunk.mesh); chunk.needsRebuild = false;
            }
            getBlockGlobal(cx, cz, lx, y, lz) {
                const chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
                const wrappedWx = modWrap(cx * CHUNK_SIZE + lx, MAP_SIZE);
                const wrappedWz = modWrap(cz * CHUNK_SIZE + lz, MAP_SIZE);
                const newCx = Math.floor(wrappedWx / CHUNK_SIZE);
                const newCz = Math.floor(wrappedWz / CHUNK_SIZE);
                const newLx = modWrap(wrappedWx, CHUNK_SIZE);
                const newLz = modWrap(wrappedWz, CHUNK_SIZE);
                const chunk = this.getChunk(newCx, newCz);
                if (!chunk.generated) this.generateChunk(chunk);
                return chunk.get(newLx, y, newLz);
            }
            setBlockGlobal(wx, wy, wz, bid) {
                if (wy < 0 || wy >= MAX_HEIGHT) return;
                const wrappedWx = modWrap(wx, MAP_SIZE);
                const wrappedWz = modWrap(wz, MAP_SIZE);
                const cx = Math.floor(wrappedWx / CHUNK_SIZE);
                const cz = Math.floor(wrappedWz / CHUNK_SIZE);
                const lx = Math.floor(wrappedWx % CHUNK_SIZE);
                const lz = Math.floor(wrappedWz % CHUNK_SIZE);
                const chunk = this.getChunk(cx, cz);
                if (!chunk.generated) this.generateChunk(chunk);
                const prev = chunk.get(lx, wy, lz);
                if (prev === bid) return;
                chunk.set(lx, wy, lz, bid);
                const key = chunk.key;
                if (!CHUNK_DELTAS.has(key)) CHUNK_DELTAS.set(key, []);
                CHUNK_DELTAS.get(key).push({ x: lx, y: wy, z: lz, b: bid });
                chunk.needsRebuild = true;
                safePlayAudio(soundPlace);
                updateSaveChangesButton();
            }
            applyDeltasToChunk(chunkKey, changes) {
                const normalizedKey = chunkKey.replace(/^#/, '');
                const parsed = parseChunkKey(normalizedKey);
                if (!parsed) {
                    console.log('[ChunkManager] Invalid JSON chunk key:', chunkKey);
                    return;
                }
                const chunk = this.chunks.get(normalizedKey);
                if (!chunk) {
                    console.log('[ChunkManager] Chunk not found:', normalizedKey);
                    return;
                }
                console.log('%c[ChunkManager] Applying deltas to chunk:', 'color: cyan', normalizedKey, 'with', changes.length, 'changes');
                for (const d of changes) {
                    if (d.x < 0 || d.x >= CHUNK_SIZE || d.y < 0 || d.y >= MAX_HEIGHT || d.z < 0 || d.z >= CHUNK_SIZE) {
                        console.log('%c[ChunkManager] Invalid change coordinates:', 'color: red', `x: ${d.x}, y: ${d.y}, z: ${d.z}`);
                        continue;
                    }
                    chunk.set(d.x, d.y, d.z, d.b);
                }
                chunk.needsRebuild = true;
                this.buildChunkMesh(chunk);
            }
            markDirty(chunkKey) {
                const chunk = this.chunks.get(chunkKey);
                if (chunk) {
                    chunk.needsRebuild = true;
                    this.buildChunkMesh(chunk);
                }
            }
            getSurfaceY(wx, wz) {
                const wrappedWx = modWrap(Math.floor(wx), MAP_SIZE);
                const wrappedWz = modWrap(Math.floor(wz), MAP_SIZE);
                const cx = Math.floor(wrappedWx / CHUNK_SIZE);
                const cz = Math.floor(wrappedWz / CHUNK_SIZE);
                const chunk = this.getChunk(cx, cz);
                if (!chunk.generated) this.generateChunk(chunk);
                const lx = Math.floor(wrappedWx % CHUNK_SIZE);
                const lz = Math.floor(wrappedWz % CHUNK_SIZE);
                for (let y = MAX_HEIGHT - 1; y >= 0; y--) {
                    if (chunk.get(lx, y, lz) !== BLOCK_AIR && chunk.get(lx, y, lz) !== 6) return y + 1;
                }
                return SEA_LEVEL;
            }
            preloadChunks(cx, cz, radius = LOAD_RADIUS) {
                console.log('%c[Main] Preloading chunks around', 'color: cyan', cx, cz, 'radius:', radius);
                const chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
                const queue = [];
                for (let r = 0; r <= radius; r++) {
                    for (let dx = -r; dx <= r; dx++) {
                        for (let dz = -r; dz <= r; dz++) {
                            if (Math.abs(dx) === r || Math.abs(dz) === r) {
                                queue.push({ cx: cx + dx, cz: cz + dz, dist: Math.abs(dx) + Math.abs(dz) });
                            }
                        }
                    }
                }
                queue.sort((a, b) => a.dist - b.dist);
                let index = 0;
                function processNext() {
                    if (index >= queue.length) return;
                    const { cx: dcx, cz: dcz } = queue[index];
                    const wrappedCx = modWrap(dcx, chunksPerSide);
                    const wrappedCz = modWrap(dcz, chunksPerSide);
                    const chunk = this.getChunk(wrappedCx, wrappedCz);
                    if (!chunk.generated) this.generateChunk(chunk);
                    if (chunk.needsRebuild) this.buildChunkMesh(chunk);
                    index++;
                    setTimeout(processNext.bind(this), 333);
                }
                processNext.call(this);
            }
            update(playerX, playerZ) {
                const pcx = Math.floor(modWrap(playerX, MAP_SIZE) / CHUNK_SIZE);
                const pcz = Math.floor(modWrap(playerZ, MAP_SIZE) / CHUNK_SIZE);
                if (pcx !== this.lastPcx || pcz !== this.lastPcz) {
                    this.lastPcx = pcx;
                    this.lastPcz = pcz;
                    const pendingKeys = Array.from(pending);
                    worker.postMessage({
                        type: 'cleanup_pending',
                        pcx,
                        pcz,
                        pendingKeys,
                        chunksPerSide: CHUNKS_PER_SIDE,
                        pollRadius: POLL_RADIUS
                    });
                }
                const needed = new Set();
                // Keep spawn point chunks loaded
                const spawnCx = Math.floor(spawnPoint.x / CHUNK_SIZE);
                const spawnCz = Math.floor(spawnPoint.z / CHUNK_SIZE);
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dz = -1; dz <= 1; dz++) {
                        const cx = modWrap(spawnCx + dx, CHUNKS_PER_SIDE);
                        const cz = modWrap(spawnCz + dz, CHUNKS_PER_SIDE);
                        const key = makeChunkKey(worldName, cx, cz);
                        needed.add(key);
                    }
                }
                // Load player vicinity chunks
                for (let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
                    for (let dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
                        const cx = modWrap(pcx + dx, CHUNKS_PER_SIDE);
                        const cz = modWrap(pcz + dz, CHUNKS_PER_SIDE);
                        const ch = this.getChunk(cx, cz);
                        needed.add(ch.key);
                        if (!ch.generated) this.generateChunk(ch);
                        if (ch.needsRebuild || !ch.mesh) this.buildChunkMesh(ch);
                    }
                }
                // Unload chunks outside radius, except spawn chunks
                for (const [k, ch] of this.chunks.entries()) {
                    if (!needed.has(k)) {
                        if (ch.mesh) {
                            meshGroup.remove(ch.mesh);
                            disposeObject(ch.mesh);
                            ch.mesh = null;
                        }
                        // Optional: Keep chunk data in memory for quick reload
                        // this.chunks.delete(k); // Uncomment to fully unload
                    }
                }
                if (mobs.length < 10) spawnMobs(10 - mobs.length);
            }
        }
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 2000);
            camera.position.set(0, 34, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
            document.body.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.maxPolarAngle = Math.PI / 2;
            controls.minDistance = 2;
            controls.maxDistance = 100;
            controls.enabled = false;
            const dir = new THREE.DirectionalLight(0xffffff, 0.95);
            dir.position.set(100, 200, 100);
            scene.add(dir);
            scene.add(new THREE.AmbientLight(0xffffff, 0.45));
            meshGroup = new THREE.Group(); scene.add(meshGroup);
            initSky();
            renderer.domElement.addEventListener('pointerdown', (e) => onPointerDown(e));
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (cameraMode === 'first') {
                    const delta = e.deltaY > 0 ? 1 : -1;
                    selectedHotIndex = (selectedHotIndex + delta + INVENTORY.length) % INVENTORY.length;
                    updateHotbarUI();
                }
            });
            renderer.domElement.addEventListener('click', () => {
                if (cameraMode === 'first' && !mouseLocked) {
                    try {
                        renderer.domElement.requestPointerLock();
                        mouseLocked = true;
                        document.getElementById('crosshair').style.display = 'block';
                    } catch (e) {
                        console.warn('Pointer lock failed:', e);
                        addMessage('Pointer lock failed. Please serve over HTTPS or ensure allow-pointer-lock is set in iframe.');
                    }
                }
            });
            document.addEventListener('pointerlockchange', () => {
                mouseLocked = document.pointerLockElement === renderer.domElement;
                document.getElementById('crosshair').style.display = mouseLocked && cameraMode === 'first' ? 'block' : 'none';
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && mouseLocked) {
                    document.exitPointerLock();
                    mouseLocked = false;
                }
            });
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (cameraMode === 'first' && mouseLocked) {
                    const sensitivity = 0.002;
                    player.yaw -= e.movementX * sensitivity;
                    player.pitch -= e.movementY * sensitivity;
                    player.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.pitch));
                    camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = innerWidth / innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth, innerHeight);
                updateMinimap();
            });
            createPlayerAvatar();
        }
        let avatarGroup;
        function createPlayerAvatar() {
            avatarGroup = new THREE.Group();
            const legMat = new THREE.MeshStandardMaterial({ color: 0x6b8cff });
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2b8f87 });
            const headMat = new THREE.MeshStandardMaterial({ color: 0xf2c57c });
            const legGeo = new THREE.BoxGeometry(0.4, 0.9, 0.4);
            const bodyGeo = new THREE.BoxGeometry(0.8, 1.2, 0.4);
            const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const leftLeg = new THREE.Mesh(legGeo, legMat); leftLeg.position.set(-0.25, 0.45, 0);
            const rightLeg = new THREE.Mesh(legGeo, legMat); rightLeg.position.set(0.25, 0.45, 0);
            const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.set(0, 1.2, 0);
            const head = new THREE.Mesh(headGeo, headMat); head.position.set(0, 2.0, 0);
            avatarGroup.add(leftLeg, rightLeg, body, head);
            scene.add(avatarGroup);
        }
        function initHotbar() {
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            for (let i = 0; i < 32; i++) {
                const slot = document.createElement('div');
                slot.className = 'hot-slot';
                slot.dataset.index = i;
                const label = document.createElement('div');
                label.className = 'hot-label';
                const count = document.createElement('div');
                count.className = 'hot-count';
                slot.appendChild(label);
                slot.appendChild(count);
                hotbar.appendChild(slot);
                slot.addEventListener('click', () => {
                    document.querySelectorAll('.hot-slot').forEach(x => x.classList.remove('active'));
                    slot.classList.add('active');
                    selectedHotIndex = i;
                    updateHotbarUI();
                });
                slot.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (INVENTORY[i] && INVENTORY[i].count > 0) {
                        trashIndex = i;
                        document.getElementById('trashItemName').innerText = `Trash ${BLOCKS[INVENTORY[i].id].name} x${INVENTORY[i].count} ? `;
                        document.getElementById('trashConfirm').style.display = 'block';
                    }
                });
            }
            updateHotbarUI();
        }
        function updateHotbarUI() {
            const hotbar = document.getElementById('hotbar');
            const slots = hotbar.querySelectorAll('.hot-slot');
            slots.forEach((s, idx) => {
                const item = INVENTORY[idx];
                const id = item ? item.id : null;
                const count = item ? item.count : 0;
                const color = id && BLOCKS[id] ? hexToRgb(BLOCKS[id].color) : [0, 0, 0];
                s.style.background = `rgba(${color.join(',')}, ${id ? 0.45 : 0.2})`;
                s.querySelector('.hot-label').innerText = id && BLOCKS[id] ? BLOCKS[id].name : '';
                s.querySelector('.hot-count').innerText = count > 0 ? count : '';
                s.classList.toggle('active', idx === selectedHotIndex);
            });
            selectedBlockId = INVENTORY[selectedHotIndex] ? INVENTORY[selectedHotIndex].id : null;
            const slotWidth = 56 + 8; // Width of slot (56px) + gap (8px)
            // Set scrollLeft precisely without animation
            hotbar.scrollLeft = (selectedHotIndex - 4) * slotWidth;
        }
        function addToInventory(id, count) {
            for (let i = 0; i < INVENTORY.length; i++) {
                if (INVENTORY[i] && INVENTORY[i].id === id && INVENTORY[i].count < 64) {
                    const space = 64 - INVENTORY[i].count;
                    INVENTORY[i].count += Math.min(count, space);
                    count -= space;
                    updateHotbarUI();
                    if (count <= 0) return;
                }
            }
            for (let i = 0; i < INVENTORY.length; i++) {
                if (!INVENTORY[i] || INVENTORY[i].count === 0) {
                    INVENTORY[i] = { id, count: Math.min(count, 64) };
                    count -= 64;
                    updateHotbarUI();
                    if (count <= 0) return;
                }
            }
            addMessage('Inventory full');
        }
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return [r, g, b];
        }
        let trashIndex = -1;
        document.getElementById('trashCancel').addEventListener('click', () => {
            document.getElementById('trashConfirm').style.display = 'none';
            trashIndex = -1;
        });
        document.getElementById('trashOk').addEventListener('click', () => {
            if (trashIndex >= 0) {
                INVENTORY[trashIndex] = null;
                updateHotbarUI();
                addMessage('Item trashed');
            }
            document.getElementById('trashConfirm').style.display = 'none';
            trashIndex = -1;
        });
        function attemptCraft(recipe) {
            const need = Object.assign({}, recipe.requires);
            const consumed = [];
            for (let i = 0; i < INVENTORY.length; i++) {
                const s = INVENTORY[i];
                if (!s || s.count === 0) continue;
                if (need[s.id]) {
                    const take = Math.min(s.count, need[s.id]);
                    need[s.id] -= take;
                    consumed.push({ slot: i, take });
                    if (need[s.id] <= 0) delete need[s.id];
                }
            }
            if (Object.keys(need).length > 0) {
                addMessage('Missing materials');
                return;
            }
            for (const c of consumed) {
                INVENTORY[c.slot].count -= c.take;
                if (INVENTORY[c.slot].count <= 0) INVENTORY[c.slot] = null;
            }
            addToInventory(recipe.out.id, recipe.out.count);
            addMessage('Crafted ' + BLOCKS[recipe.out.id].name);
            updateHotbarUI();
        }
        function openCrafting() {
            isPromptOpen = true;
            const m = document.getElementById('craftModal');
            m.style.display = 'block';
            const list = document.getElementById('recipeList');
            list.innerHTML = '';
            for (const r of RECIPES) {
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                row.style.alignItems = 'center';
                row.style.marginTop = '8px';
                const info = document.createElement('div');
                info.innerText = `${BLOCKS[r.out.id].name} x${r.out.count}`;
                const reqs = document.createElement('div');
                reqs.style.opacity = 0.85;
                reqs.innerText = 'Requires: ' + Object.entries(r.requires).map(([k, v]) => `${BLOCKS[k].name || k} x${v}`).join(', ');
                const btn = document.createElement('button');
                btn.innerText = 'Craft';
                btn.onclick = () => { attemptCraft(r); };
                row.appendChild(info);
                row.appendChild(reqs);
                row.appendChild(btn);
                list.appendChild(row);
            }
        }
        function safePlayAudio(audioElement) {
            if (!audioElement) return;
            const playPromise = audioElement.play();
            if (playPromise !== undefined) {
                playPromise.catch(e => {
                    if (!audioErrorLogged) {
                        console.warn(`Audio playback failed for ${audioElement.id}: `, e);
                        addMessage('Audio playback issue detected', 3000);
                        audioErrorLogged = true;
                    }
                });
            }
        }
        function onPointerDown(e) {
            if (cameraMode !== 'first') return;
            e.preventDefault();
            raycaster.setFromCamera(pointer, camera);
            raycaster.far = 5;
            const mobHits = mobs.map(m => ({ mob: m, intersect: raycaster.intersectObject(m.mesh)[0] }))
                .filter(h => h.intersect)
                .sort((a, b) => a.intersect.distance - b.intersect.distance);
            if (mobHits.length > 0) {
                const mob = mobHits[0].mob;
                mob.hurt(4);
                safePlayAudio(soundHit);
                addMessage('Hit mob!', 800);
                return;
            }
            const ints = raycaster.intersectObject(meshGroup, true);
            if (ints.length === 0) return;
            const h = ints[0];
            const p = h.point;
            const norm = h.face.normal;
            const wx = Math.round(p.x - norm.x * 0.01);
            const wy = Math.round(p.y - norm.y * 0.01);
            const wz = Math.round(p.z - norm.z * 0.01);
            if (e.button === 0) {
                removeBlockAt(wx, wy, wz);
                safePlayAudio(soundBreak);
            } else if (e.button === 2) {
                const placeX = Math.round(p.x + norm.x * 0.51);
                const placeY = Math.round(p.y + norm.y * 0.51);
                const placeZ = Math.round(p.z + norm.z * 0.51);
                placeBlockAt(placeX, placeY, placeZ, selectedBlockId);
            }
        }
        function attackAtPoint(point) {
            for (const m of mobs) {
                if (m.mesh.position.distanceTo(point) < 1.5) {
                    m.hurt(4);
                    addMessage('Hit mob!', 800);
                    safePlayAudio(soundHit);
                    return true;
                }
            }
            return false;
        }
        function removeBlockAt(wx, wy, wz) {
            const b = getBlockAt(wx, wy, wz);
            if (!b || b === BLOCK_AIR || b === 1 || b === 6) {
                addMessage('Cannot break that block');
                return;
            }
            const cx = Math.floor(modWrap(wx, MAP_SIZE) / CHUNK_SIZE);
            const cz = Math.floor(modWrap(wz, MAP_SIZE) / CHUNK_SIZE);
            const chunkKey = makeChunkKey(worldName, cx, cz);
            const canEdit = checkChunkOwnership(chunkKey, userName);
            if (!canEdit) {
                addMessage(`Cannot break block in chunk ${chunkKey}: owned by another user`);
                return;
            }
            chunkManager.setBlockGlobal(wx, wy, wz, BLOCK_AIR);
            addToInventory(b, 1);
            addMessage('Picked up ' + (BLOCKS[b]?.name || b));
            safePlayAudio(soundBreak);
        }
        function placeBlockAt(wx, wy, wz, bid) {
            if (!bid) {
                addMessage('No item selected');
                return;
            }
            const item = INVENTORY[selectedHotIndex];
            if (!item || item.id !== bid || item.count <= 0) {
                addMessage('No item to place');
                return;
            }
            const dist = Math.hypot(player.x - wx, player.y - wy, player.z - wz);
            if (dist > 5) {
                addMessage('Too far to place');
                return;
            }
            const cur = getBlockAt(wx, wy, wz);
            if (cur !== BLOCK_AIR && cur !== 6) {
                addMessage('Cannot place here');
                return;
            }
            if (checkCollisionWithPlayer(wx, wy, wz)) {
                addMessage('Cannot place inside player');
                return;
            }
            for (const m of mobs) {
                if (Math.abs(m.pos.x - wx) < 0.9 && Math.abs(m.pos.y - wy) < 0.9 && Math.abs(m.pos.z - wz) < 0.9) {
                    addMessage('Cannot place inside mob');
                    return;
                }
            }
            const cx = Math.floor(modWrap(wx, MAP_SIZE) / CHUNK_SIZE);
            const cz = Math.floor(modWrap(wz, MAP_SIZE) / CHUNK_SIZE);
            const chunkKey = makeChunkKey(worldName, cx, cz);
            const canEdit = checkChunkOwnership(chunkKey, userName);
            if (!canEdit) {
                addMessage(`Cannot place block in chunk ${chunkKey}: owned by another user`);
                return;
            }
            chunkManager.setBlockGlobal(wx, wy, wz, bid);
            item.count -= 1;
            if (item.count <= 0) INVENTORY[selectedHotIndex] = null;
            addMessage('Placed ' + (BLOCKS[bid]?.name || bid));
            updateHotbarUI();
            safePlayAudio(soundPlace);
        }
        function checkCollisionWithPlayer(wx, wy, wz) {
            const minX = player.x - player.width / 2;
            const maxX = player.x + player.width / 2;
            const minY = player.y;
            const maxY = player.y + player.height;
            const minZ = player.z - player.width / 2;
            const maxZ = player.z + player.width / 2;
            return wx >= minX && wx <= maxX && wy >= minY && wy <= maxY && wz >= minZ && wz <= maxZ;
        }
        function getBlockAt(wx, wy, wz) {
            const wrappedWx = modWrap(Math.floor(wx), MAP_SIZE);
            const wrappedWz = modWrap(Math.floor(wz), MAP_SIZE);
            const cx = Math.floor(wrappedWx / CHUNK_SIZE);
            const cz = Math.floor(wrappedWz / CHUNK_SIZE);
            const chunk = chunkManager.getChunk(cx, cz);
            if (!chunk.generated) chunkManager.generateChunk(chunk);
            const lx = Math.floor(wrappedWx % CHUNK_SIZE);
            const lz = Math.floor(wrappedWz % CHUNK_SIZE);
            return chunk.get(lx, wy, lz);
        }

        function handlePlayerDeath() {
            if (!deathScreenShown) {
                document.getElementById('deathScreen').style.display = 'flex';
                INVENTORY = new Array(32).fill(null);
                player.score = 0; 
                const scoreElement = document.getElementById('score');
                if (scoreElement) scoreElement.innerText = player.score; 
                player.health = 0;
                updateHealthBar();
                updateHotbarUI();
                addMessage('You died! All items and score lost.', 5000);
                deathScreenShown = true;
                console.log('Death: score reset to', player.score); 
            }
        }

        function respawnPlayer() {
            const targetX = spawnPoint.x;
            const targetY = 100; 
            const targetZ = spawnPoint.z;
            if (!checkCollision(targetX, targetY, targetZ)) {
                player.x = targetX;
                player.y = targetY;
                player.z = targetZ;
                player.vy = 0;
                player.onGround = false;
                player.health = 20;
                player.yaw = 0;
                player.pitch = 0;
            } else {
                let found = false;
                for (let dy = 0; dy <= 5; dy++) {
                    if (!checkCollision(targetX, targetY + dy, targetZ)) {
                        player.x = targetX;
                        player.y = targetY + dy;
                        player.z = targetZ;
                        player.vy = 0;
                        player.onGround = false;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    player.x = targetX;
                    player.y = chunkManager.getSurfaceY(targetX, targetZ) + 1;
                    player.z = targetZ;
                    player.vy = 0;
                    player.onGround = true;
                }
                player.health = 20;
                player.yaw = 0;
                player.pitch = 0;
            }
            // Reset inventory and UI
            INVENTORY = new Array(32).fill(null);
            updateHotbarUI();
            updateHealthBar();
            document.getElementById('health').innerText = player.health;
            // Force-load chunks around spawn
            const newCx = Math.floor(targetX / CHUNK_SIZE);
            const newCz = Math.floor(targetZ / CHUNK_SIZE);
            chunkManager.preloadChunks(newCx, newCz, LOAD_RADIUS);
            for (let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
                for (let dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
                    const cx = modWrap(newCx + dx, CHUNKS_PER_SIDE);
                    const cz = modWrap(newCz + dz, CHUNKS_PER_SIDE);
                    const chunk = chunkManager.getChunk(cx, cz);
                    if (!chunk.generated) chunkManager.generateChunk(chunk);
                    if (chunk.needsRebuild || !chunk.mesh) {
                        chunkManager.buildChunkMesh(chunk);
                    }
                }
            }
            chunkManager.update(player.x, player.z);
            // Reset controls for first-person mode
            if (cameraMode === 'first') {
                camera.position.set(player.x, player.y + 1.62, player.z);
                camera.rotation.set(0, 0, 0, 'YXZ');
                try {
                    renderer.domElement.requestPointerLock();
                    mouseLocked = true;
                    document.getElementById('crosshair').style.display = 'block';
                } catch (e) {
                    console.warn('Pointer lock failed:', e);
                    addMessage('Pointer lock failed. Serve over HTTPS or check iframe permissions.', 3000);
                }
            } else {
                camera.position.set(player.x, player.y + 5, player.z + 10);
                controls.target.set(player.x, player.y + 0.6, player.z);
                controls.update();
            }
            // Hide death screen and reset flag
            document.getElementById('deathScreen').style.display = 'none';
            deathScreenShown = false;
            addMessage('Respawned at spawn point', 3000);
        }

        class Mob {
            constructor(x, z) {
                this.pos = new THREE.Vector3(x, chunkManager.getSurfaceY(x, z) + 1, z);
                this.hp = 6;
                this.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshLambertMaterial({ color: 0x9bff9b }));
                this.mesh.position.copy(this.pos);
                this.originalColor = new THREE.Color(0x9bff9b);
                scene.add(this.mesh);
                this.speed = 0.02 + Math.random() * 0.03;
                this.attackCooldown = 0;
                this.flashEnd = 0;
            }
            update(dt) {
                this.pos.y = chunkManager.getSurfaceY(this.pos.x, this.pos.z) + Math.sin(Date.now() * 0.003 + this.mesh.id) * 0.4 + 0.5;
                if (Date.now() < this.flashEnd) {
                    this.mesh.material.color.set(0xff0000);
                } else {
                    this.mesh.material.color.copy(this.originalColor);
                }
                const dx = player.x - this.pos.x; const dz = player.z - this.pos.z;
                const dist = Math.hypot(dx, dz);
                if (dist < 10) {
                    const vx = dx / dist * this.speed;
                    const vz = dz / dist * this.speed;
                    const newX = modWrap(this.pos.x + vx * dt * 60, MAP_SIZE);
                    const newZ = modWrap(this.pos.z + vz * dt * 60, MAP_SIZE);
                    if (!checkCollisionWithBlock(newX, this.pos.y, newZ) && !checkCollisionWithPlayer(newX, this.pos.y, newZ)) {
                        this.pos.x = newX;
                        this.pos.z = newZ;
                    }
                    if (dist < 1.2 && Date.now() - this.attackCooldown > 800) {
                        this.attackCooldown = Date.now();
                        if (Date.now() - lastDamageTime > 800) {
                            player.health = Math.max(0, player.health - 1);
                            lastDamageTime = Date.now();
                            const healthElement = document.getElementById('health');
                            if (healthElement) healthElement.innerText = player.health;
                            updateHealthBar();
                            addMessage('Hit! HP: ' + player.health, 1000);
                            if (player.health <= 0) {
                                handlePlayerDeath();
                            }
                        }
                    }
                } else {
                    const newX = modWrap(this.pos.x + (Math.sin(Date.now() * 0.001 + this.mesh.id) * 0.002) * dt * 60, MAP_SIZE);
                    const newZ = modWrap(this.pos.z + (Math.cos(Date.now() * 0.001 + this.mesh.id) * 0.002) * dt * 60, MAP_SIZE);
                    if (!checkCollisionWithBlock(newX, this.pos.y, newZ) && !checkCollisionWithPlayer(newX, this.pos.y, newZ)) {
                        this.pos.x = newX;
                        this.pos.z = newZ;
                    }
                }
                this.mesh.position.copy(this.pos);
            }
            hurt(dmg) {
                this.hp -= dmg;
                this.flashEnd = Date.now() + 200;
                if (this.hp <= 0) this.die();
                safePlayAudio(soundHit);
            }
            die() {
                try { scene.remove(this.mesh); disposeObject(this.mesh); } catch (e) { }
                player.score += 10;
                const scoreElement = document.getElementById('score');
                if (scoreElement) scoreElement.innerText = player.score;
                mobs = mobs.filter(m => m !== this);
                addMessage('Mob defeated! +10 score');
            }
        }
        function spawnMobs(count) {
            const loadedChunks = Array.from(chunkManager.chunks.keys());
            if (loadedChunks.length === 0) {
                console.log('%c[SpawnMobs] No loaded chunks, cannot spawn mobs', 'color: orange');
                return;
            }
            console.log('%c[SpawnMobs] Spawning', 'color: green', count, 'mobs in', loadedChunks.length, 'loaded chunks');
            for (let i = 0; i < count; i++) {
                const randomChunkKey = loadedChunks[Math.floor(Math.random() * loadedChunks.length)];
                const parsed = parseChunkKey(randomChunkKey);
                if (!parsed) {
                    console.log('%c[SpawnMobs] Invalid chunk key:', 'color: red', randomChunkKey);
                    continue;
                }
                const cx = parsed.cx;
                const cz = parsed.cz;
                const baseX = cx * CHUNK_SIZE;
                const baseZ = cz * CHUNK_SIZE;
                const lx = Math.random() * CHUNK_SIZE;
                const lz = Math.random() * CHUNK_SIZE;
                const x = modWrap(baseX + lx, MAP_SIZE);
                const z = modWrap(baseZ + lz, MAP_SIZE);
                const m = new Mob(x, z);
                mobs.push(m);
                console.log('%c[SpawnMobs] Spawned mob at x:', 'color: green', x, 'z:', z);
            }
        }
        function isSolid(id) {
            return id !== 0 && id !== 6 && id !== 12 && id !== 8 && id !== 16 && id !== 17 && id !== 100 && id !== 101 && id !== 102 && id !== 103 && id !== 104 && id !== 111 && id !== 112 && id !== 113 && id !== 114 && id !== 116 && id !== 117;
        }
        function checkCollisionWithBlock(newX, newY, newZ) {
            const minX = newX - 0.45;
            const minY = newY;
            const minZ = newZ - 0.45;
            const maxX = newX + 0.45;
            const maxY = newY + 0.9;
            const maxZ = newZ + 0.45;
            for (let bx = Math.floor(minX); bx <= Math.floor(maxX); bx++) {
                for (let by = Math.floor(minY); by <= Math.floor(maxY); by++) {
                    for (let bz = Math.floor(minZ); bz <= Math.floor(maxZ); bz++) {
                        if (isSolid(getBlockAt(bx, by, bz))) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        function checkCollision(newX, newY, newZ) {
            const minX = newX - player.width / 2 + 0.001;
            const minY = newY + 0.001;
            const maxX = newX + player.width / 2 - 0.001;
            const maxY = newY + player.height - 0.001;
            const minZ = newZ - player.width / 2 + 0.001;
            const maxZ = newZ + player.width / 2 - 0.001;
            for (let bx = Math.floor(minX); bx <= Math.floor(maxX); bx++) {
                for (let by = Math.floor(minY); by <= Math.floor(maxY); by++) {
                    for (let bz = Math.floor(minZ); bz <= Math.floor(maxZ); bz++) {
                        if (isSolid(getBlockAt(bx, by, bz))) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        function pushPlayerOut() {
            const directions = [
                { dx: 0.2, dz: 0 }, { dx: -0.2, dz: 0 }, { dx: 0, dz: 0.2 }, { dx: 0, dz: -0.2 },
                { dx: 0.2, dz: 0.2 }, { dx: 0.2, dz: -0.2 }, { dx: -0.2, dz: 0.2 }, { dx: -0.2, dz: -0.2 }
            ];
            for (let yOffset = 0; yOffset <= 2; yOffset += 0.2) {
                for (const dir of directions) {
                    const newX = modWrap(player.x + dir.dx, MAP_SIZE);
                    const newZ = modWrap(player.z + dir.dz, MAP_SIZE);
                    const newY = player.y + yOffset;
                    if (!checkCollision(newX, newY, newZ)) {
                        player.x = newX;
                        player.y = newY;
                        player.z = newZ;
                        player.vy = 0;
                        player.onGround = true;
                        addMessage('Pushed out of block');
                        return true;
                    }
                }
            }
            return false;
        }
        let minimapCtx;
        function initMinimap() {
            const canvas = document.getElementById('minimap');
            minimapCtx = canvas.getContext('2d');
            canvas.width = 120;
            canvas.height = 120;
            updateMinimap();
        }
        function updateMinimap() {
            if (!minimapCtx) return;
            const canvas = minimapCtx.canvas;
            minimapCtx.clearRect(0, 0, canvas.width, canvas.height);
            minimapCtx.fillStyle = 'rgba(0,0,0,0.3)';
            minimapCtx.fillRect(0, 0, canvas.width, canvas.height);
            const scale = canvas.width / 40;
            const cx = canvas.width / 2;
            const cz = canvas.height / 2;
            minimapCtx.fillStyle = '#ffffff';
            minimapCtx.fillRect(cx - 2, cz - 2, 4, 4);
            minimapCtx.fillStyle = '#9bff9b';
            for (const m of mobs) {
                const dx = m.pos.x - player.x;
                const dz = m.pos.z - player.z;
                if (Math.abs(dx) <= 20 && Math.abs(dz) <= 20) {
                    const px = cx + dx * scale;
                    const pz = cz + dz * scale;
                    minimapCtx.fillRect(px - 2, pz - 2, 4, 4);
                }
            }
        }
        let keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 't') toggleCameraMode();
            if (e.key.toLowerCase() === 'r') openCrafting();
            if (e.key.toLowerCase() === 'p') {
                isPromptOpen = true;
                document.getElementById('teleportModal').style.display = 'block';
                document.getElementById('teleportX').value = '';
                document.getElementById('teleportY').value = '';
                document.getElementById('teleportZ').value = '';
            }
            if (e.key.toLowerCase() === 'x' && CHUNK_DELTAS.size > 0) downloadSession();
            if (e.key.toLowerCase() === 'j' && knownUsers.has(userName)) {
                document.getElementById('joinScriptBtn').click();
            }
            if (e.key.toLowerCase() === ' ') {
                playerJump();
                safePlayAudio(soundJump);
            }
        });
        window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
        function playerJump() {
            if (player.onGround) {
                player.vy = 8.5;
                player.onGround = false;
                safePlayAudio(soundJump);
            }
        }
        function toggleCameraMode() {
            cameraMode = (cameraMode === 'third') ? 'first' : 'third';
            addMessage('Camera: ' + cameraMode);
            controls.enabled = cameraMode === 'third';
            avatarGroup.visible = cameraMode === 'third';
            if (cameraMode === 'third') {
                camera.position.set(player.x, player.y + 5, player.z + 10);
                controls.target.set(player.x, player.y + 0.6, player.z);
                controls.update();
                document.exitPointerLock();
                mouseLocked = false;
                document.getElementById('crosshair').style.display = 'none';
            } else {
                try {
                    renderer.domElement.requestPointerLock();
                    mouseLocked = true;
                    document.getElementById('crosshair').style.display = 'block';
                } catch (e) {
                    console.warn('Pointer lock failed:', e);
                    addMessage('Pointer lock failed. Please serve over HTTPS or ensure allow-pointer-lock is set in iframe.');
                    document.getElementById('crosshair').style.display = 'block';
                }
                player.yaw = 0;
                player.pitch = 0;
                camera.rotation.set(0, 0, 0, 'YXZ');
            }
        }


        function gameLoop(now) {
            const dt = Math.min(0.06, (now - lastFrame) / 1000);
            lastFrame = now;
            if (player.health <= 0) {
                handlePlayerDeath();
            }
            if (deathScreenShown) {
                
                mobs.forEach(m => m.update(dt));
                updateSky(dt);
                updateMinimap();
                const scoreElement = document.getElementById('score');
                if (scoreElement) scoreElement.innerText = player.score;
                renderer.render(scene, camera);
            } else {
                const speed = 4.3;
                let mvx = 0, mvz = 0;
                if (isMobile()) {
                    if (joystick.up) mvz -= 1;
                    if (joystick.down) mvz += 1;
                    if (joystick.left) mvx -= 1;
                    if (joystick.right) mvx += 1;
                } else {
                    if (keys['s']) mvz -= 1;
                    if (keys['w']) mvz += 1;
                    if (keys['a']) mvx -= 1;
                    if (keys['d']) mvx += 1;
                }
                let forwardDir, rightDir;
                if (cameraMode === 'first') {
                    forwardDir = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(player.pitch, player.yaw, 0, 'YXZ'));
                    forwardDir.y = 0;
                    forwardDir.normalize();
                    rightDir = new THREE.Vector3().crossVectors(forwardDir, new THREE.Vector3(0, 1, 0)).normalize();
                } else {
                    forwardDir = new THREE.Vector3(-Math.sin(player.yaw), 0, -Math.cos(player.yaw)).normalize();
                    rightDir = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), forwardDir).normalize();
                }
                const moveVec = new THREE.Vector3();
                moveVec.addScaledVector(forwardDir, mvz);
                moveVec.addScaledVector(rightDir, mvx);
                if (moveVec.length() > 0.001) moveVec.normalize();
                const dx = moveVec.x * speed * dt;
                const dz = moveVec.z * speed * dt;
                let newX = modWrap(player.x + dx, MAP_SIZE);
                let newZ = modWrap(player.z + dz, MAP_SIZE);
                if (!checkCollision(newX, player.y, newZ)) {
                    player.x = newX;
                    player.z = newZ;
                } else {
                    if (!checkCollision(newX, player.y, player.z)) player.x = newX;
                    if (!checkCollision(player.x, player.y, newZ)) player.z = newZ;
                }
                player.vy -= 16.0 * dt;
                const dy = player.vy * dt;
                let newY = player.y + dy;
                if (!checkCollision(player.x, newY, newZ)) {
                    player.y = newY;
                    player.onGround = false;
                } else {
                    if (dy < 0) {
                        player.y = Math.ceil(newY - 0.001);
                        player.vy = 0;
                        player.onGround = true;
                    } else if (dy > 0) {
                        player.y = Math.floor(newY + player.height) - player.height;
                        player.vy = 0;
                    }
                }
                if (checkCollision(player.x, player.y, player.z)) {
                    if (!pushPlayerOut()) {
                        player.y = chunkManager.getSurfaceY(player.x, player.z) + 1;
                        player.vy = 0;
                        player.onGround = true;
                        addMessage('Stuck in block, respawned');
                    }
                }
                if (player.y < -10) {
                    player.x = modWrap(player.x, MAP_SIZE);
                    player.z = modWrap(player.z, MAP_SIZE);
                    player.y = chunkManager.getSurfaceY(player.x, player.z) + 1;
                    player.vy = 0;
                    player.onGround = true;
                    addMessage('Fell off world, respawned');
                }
                if (Date.now() - lastDamageTime > 30000 && Date.now() - lastRegenTime > 10000 && player.health < 20) {
                    player.health = Math.min(20, player.health + 1);
                    lastRegenTime = Date.now();
                    const healthElement = document.getElementById('health');
                    if (healthElement) healthElement.innerText = player.health;
                    updateHealthBar();
                    addMessage('Health regenerated: ' + player.health, 1000);
                }
                const distFromSpawn = Math.hypot(player.x - spawnPoint.x, player.z - spawnPoint.z);
                document.getElementById('homeIcon').style.display = distFromSpawn > 10 ? 'inline' : 'none';
                avatarGroup.position.set(player.x, player.y - 0.9, player.z);
                if (cameraMode === 'third') {
                    avatarGroup.rotation.y = player.yaw;
                }
                chunkManager.update(player.x, player.z);
                mobs.forEach(m => m.update(dt));
                updateSky(dt);
                updateMinimap();
                const posLabel = document.getElementById('posLabel');
                if (posLabel) posLabel.innerText = `${Math.floor(player.x)}, ${Math.floor(player.y)}, ${Math.floor(player.z)}`;
                if (cameraMode === 'third') {
                    controls.target.set(player.x, player.y + 0.6, player.z);
                    controls.update();
                } else {
                    const headPos = new THREE.Vector3(player.x, player.y + 1.62, player.z);
                    camera.position.copy(headPos);
                }
                renderer.render(scene, camera);
            }
            requestAnimationFrame(gameLoop);
        }

        function performAttack() {
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
            const origin = (cameraMode === 'first') ? new THREE.Vector3(player.x, player.y + 1.62, player.z) : camera.position.clone();
            raycaster.setFromCamera(pointer, camera);
            raycaster.far = 5;
            const mobHits = mobs.map(m => ({ mob: m, intersect: raycaster.intersectObject(m.mesh)[0] }))
                .filter(h => h.intersect)
                .sort((a, b) => a.intersect.distance - b.intersect.distance);
            if (mobHits.length > 0) {
                const mob = mobHits[0].mob;
                mob.hurt(4);
                safePlayAudio(soundHit);
                addMessage('Hit mob!', 800);
                return;
            }
            for (let d = 0.6; d < 3.0; d += 0.6) {
                const p = origin.clone().addScaledVector(dir, d);
                const bx = Math.round(p.x), by = Math.round(p.y), bz = Math.round(p.z);
                const b = getBlockAt(bx, by, bz);
                if (b && b !== BLOCK_AIR && b !== 6) {
                    removeBlockAt(bx, by, bz); return;
                }
            }
        }
        async function downloadSession() {
            const out = {
                world: worldName,
                seed: worldSeed,
                user: userName,
                savedAt: new Date().toISOString(),
                deltas: [],
                profile: {
                    x: player.x,
                    y: player.y,
                    z: player.z,
                    inventory: INVENTORY
                }
            };
            for (const [k, arr] of CHUNK_DELTAS.entries()) {
                const parsed = parseChunkKey(k);
                if (parsed) {
                    out.deltas.push({ chunk: k, changes: arr }); 
                }
            }
            const blob = new Blob([JSON.stringify(out)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${worldName}_session_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            addMessage('Session downloaded');
            const chunkKeys = Array.from(CHUNK_DELTAS.keys()); 
            const chunkAddresses = await Promise.all(chunkKeys.map(async key => {
                const addr = await GetPublicAddressByKeyword(key);
                return addr ? addr.trim().replace(/^"|"$/g, '') : key; 
            }));
            // Join addresses without quotes
            document.getElementById('downloadAddressList').value = chunkAddresses.join(',');
            document.getElementById('downloadModal').style.display = 'block';
        }

        function disposeObject(obj) {
            obj.traverse((c) => {
                if (c.geometry) c.geometry.dispose();
                if (c.material) {
                    if (Array.isArray(c.material)) c.material.forEach(m => m.dispose());
                    else c.material.dispose();
                }
            });
        }
        function addMessage(txt, ttl = 2000) {
            const c = document.getElementById('messages');
            const el = document.createElement('div'); el.className = 'msg'; el.innerText = txt;
            c.prepend(el);
            setTimeout(() => { el.remove(); }, ttl);
        }
        function updateHealthBar() {
            const pct = Math.max(0, Math.min(1, player.health / 20));
            document.getElementById('healthBarInner').style.width = (pct * 100) + '%';
        }
        function updateSaveChangesButton() {
            const saveBtn = document.getElementById('saveChangesBtn');
            saveBtn.style.display = CHUNK_DELTAS.size > 0 ? 'inline-block' : 'none';
        }
        function updateHudButtons() {
            const joinScriptBtn = document.getElementById('joinScriptBtn');
            joinScriptBtn.style.display = knownUsers.has(userName) ? 'inline-block' : 'none';
            updateSaveChangesButton();
        }

        function updateHud() {
            const scoreElement = document.getElementById('score');
            if (scoreElement) scoreElement.innerText = player.score;
            const healthElement = document.getElementById('health');
            if (healthElement) healthElement.innerText = player.health;
            const posLabel = document.getElementById('posLabel');
            if (posLabel) posLabel.innerText = `${Math.floor(player.x)}, ${Math.floor(player.y)}, ${Math.floor(player.z)}`;
            const distFromSpawn = Math.hypot(player.x - spawnPoint.x, player.z - spawnPoint.z);
            document.getElementById('homeIcon').style.display = distFromSpawn > 10 ? 'inline' : 'none';
            updateHealthBar();
            updateHotbarUI();
        }

        function isMobile() { return /Android|iPhone|iPad|Mobi/i.test(navigator.userAgent); }
        function setupMobile() {
            if (!isMobile()) return;
            const up = document.getElementById('mUp'), down = document.getElementById('mDown'), left = document.getElementById('mLeft'), right = document.getElementById('mRight');
            up.addEventListener('touchstart', e => { joystick.up = true; e.preventDefault(); }); up.addEventListener('touchend', e => { joystick.up = false; e.preventDefault(); });
            down.addEventListener('touchstart', e => { joystick.down = true; e.preventDefault(); }); down.addEventListener('touchend', e => { joystick.down = false; e.preventDefault(); });
            left.addEventListener('touchstart', e => { joystick.left = true; e.preventDefault(); }); left.addEventListener('touchend', e => { joystick.left = false; e.preventDefault(); });
            right.addEventListener('touchstart', e => { joystick.right = true; e.preventDefault(); }); right.addEventListener('touchend', e => { joystick.right = false; e.preventDefault(); });
            document.getElementById('mJump').addEventListener('touchstart', e => { playerJump(); safePlayAudio(soundJump); e.preventDefault(); });
            document.getElementById('mAttack').addEventListener('touchstart', e => { performAttack(); e.preventDefault(); });
            document.getElementById('mCam').addEventListener('touchstart', e => { toggleCameraMode(); e.preventDefault(); });
        }
        function updateLoginUI() {
            const worldInput = document.getElementById('worldNameInput');
            const userInput = document.getElementById('userInput');
            worldInput.addEventListener('input', () => {
                const value = worldInput.value.toLowerCase();
                const suggestions = Array.from(knownWorlds.entries())
                    .filter(([w]) => w.toLowerCase().startsWith(value))
                    .slice(0, 10);
                const suggestionsDiv = document.getElementById('worldSuggestions');
                suggestionsDiv.innerHTML = suggestions.map(([w, { discoverer }]) => `<div data-value="${w}">${w} (${discoverer})</div>`).join('');
                suggestionsDiv.style.display = suggestions.length > 0 && value ? 'block' : 'none';
            });
            userInput.addEventListener('input', () => {
                const value = userInput.value.toLowerCase();
                const suggestions = Array.from(knownUsers.keys())
                    .filter(u => u.toLowerCase().startsWith(value))
                    .slice(0, 10);
                const suggestionsDiv = document.getElementById('userSuggestions');
                suggestionsDiv.innerHTML = suggestions.map(u => `<div data-value="${u}">${u}</div>`).join('');
                suggestionsDiv.style.display = suggestions.length > 0 && value ? 'block' : 'none';
            });
            document.getElementById('worldSuggestions').addEventListener('click', (e) => {
                if (e.target.dataset.value) {
                    worldInput.value = e.target.dataset.value;
                    document.getElementById('worldSuggestions').style.display = 'none';
                }
            });
            document.getElementById('userSuggestions').addEventListener('click', (e) => {
                if (e.target.dataset.value) {
                    userInput.value = e.target.dataset.value;
                    document.getElementById('userSuggestions').style.display = 'none';
                }
            });
            document.addEventListener('click', (e) => {
                if (!worldInput.contains(e.target) && !document.getElementById('worldSuggestions').contains(e.target)) {
                    document.getElementById('worldSuggestions').style.display = 'none';
                }
                if (!userInput.contains(e.target) && !document.getElementById('userSuggestions').contains(e.target)) {
                    document.getElementById('userSuggestions').style.display = 'none';
                }
            });
        }
        async function populateSpawnChunks() {
            for (const [user, { world, username }] of spawnChunks) {
                const spawn = calculateSpawnPoint(`${user} @${world} `);
                spawnChunks.set(user, { cx: Math.floor(spawn.x / CHUNK_SIZE), cz: Math.floor(spawn.z / CHUNK_SIZE), username, world });
            }
        }
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('startBtn').addEventListener('click', async () => {
                isPromptOpen = false;
                const worldInput = document.getElementById('worldNameInput').value;
                const userInput = document.getElementById('userInput').value;
                if (worldInput.length > 8) {
                    addMessage('World name too long (max 8 chars)', 3000);
                    return;
                }
                if (userInput.length > 20) {
                    addMessage('Username too long (max 20 chars)', 3000);
                    return;
                }
                if (!worldInput || !userInput) {
                    addMessage('Please enter a world and username', 3000);
                    return;
                }
                worldName = worldInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 8);
                userName = userInput.replace(/[^a-zA-Z0-9]/g, '');
                const userWorldKey = `${userName} @${worldName} `;
                worldSeed = userWorldKey;
                const profile = await GetProfileByURN(userName);
                userAddress = profile?.Creators?.[0] || 'anonymous';
                if (!knownUsers.has(userName)) knownUsers.set(userName, userAddress);
                if (!knownWorlds.has(worldName)) {
                    knownWorlds.set(worldName, { discoverer: userName, users: new Set([userName]), toAddress: userAddress });
                } else {
                    knownWorlds.get(worldName).users.add(userName);
                }
                keywordCache.set(userAddress, userWorldKey);
                document.getElementById('loginOverlay').style.display = 'none';
                document.getElementById('hud').style.display = 'block';
                document.getElementById('hotbar').style.display = 'flex';
                document.getElementById('rightPanel').style.display = 'block';
                document.getElementById('worldLabel').textContent = worldName;
                document.getElementById('seedLabel').textContent = `Seed: ${worldSeed} `;
                updateHudButtons();
                initThree();
                initHotbar();
                chunkManager = new ChunkManager(worldSeed);
                await populateSpawnChunks();
                const spawn = calculateSpawnPoint(userWorldKey);
                player.x = spawn.x;
                player.y = spawn.y;
                player.z = spawn.z;
                spawnPoint = { x: player.x, y: player.y, z: player.z };
                player.vy = 0;
                player.onGround = true;
                const chunksPerSide = Math.floor(MAP_SIZE / CHUNK_SIZE);
                const spawnCx = Math.floor(spawn.x / CHUNK_SIZE);
                const spawnCz = Math.floor(spawn.z / CHUNK_SIZE);
                chunkManager.preloadChunks(spawnCx, spawnCz, LOAD_RADIUS);
                spawnMobs(12);
                setupMobile();
                initMinimap();
                updateHotbarUI();
                selectedBlockId = null;
                // Set initial camera mode to first-person
                cameraMode = 'first';
                controls.enabled = false; // Disable OrbitControls for first-person
                avatarGroup.visible = false; // Hide avatar in first-person mode
                camera.position.set(player.x, player.y + 1.62, player.z); // Set camera to player head position
                camera.rotation.set(0, 0, 0, 'YXZ'); // Reset rotation for first-person
                try {
                    renderer.domElement.requestPointerLock();
                    mouseLocked = true;
                    document.getElementById('crosshair').style.display = 'block';
                } catch (e) {
                    console.warn('Pointer lock failed:', e);
                    addMessage('Pointer lock failed. Please serve over HTTPS or ensure allow-pointer-lock is set in iframe.');
                    document.getElementById('crosshair').style.display = 'block';
                }
                player.yaw = 0;
                player.pitch = 0;
                lastFrame = performance.now();
                lastRegenTime = lastFrame;
                requestAnimationFrame(gameLoop);
                addMessage('Welcome ‚Äî world wraps at edges. Toggle camera with T. Good luck!');
                const healthElement = document.getElementById('health');
                if (healthElement) healthElement.innerText = player.health;
                const scoreElement = document.getElementById('score');
                if (scoreElement) scoreElement.innerText = player.score;
                startWorker();
            });

            document.getElementById('homeIcon').addEventListener('click', () => {
                const targetX = spawnPoint.x;
                const targetY = 100; // Drop from y=100 as per previous fix
                const targetZ = spawnPoint.z;
                if (!checkCollision(targetX, targetY, targetZ)) {
                    player.x = targetX;
                    player.y = targetY;
                    player.z = targetZ;
                    player.vy = 0; // Reset vertical velocity to start falling
                    player.onGround = false; // Player is in the air
                    // Force-load chunks around spawn point
                    const newCx = Math.floor(targetX / CHUNK_SIZE);
                    const newCz = Math.floor(targetZ / CHUNK_SIZE);
                    chunkManager.preloadChunks(newCx, newCz, LOAD_RADIUS);
                    // Force rebuild of all nearby chunks to ensure rendering
                    for (let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
                        for (let dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
                            const cx = modWrap(newCx + dx, CHUNKS_PER_SIDE);
                            const cz = modWrap(newCz + dz, CHUNKS_PER_SIDE);
                            const chunk = chunkManager.getChunk(cx, cz);
                            if (!chunk.generated) chunkManager.generateChunk(chunk);
                            if (chunk.needsRebuild || !chunk.mesh) {
                                chunkManager.buildChunkMesh(chunk);
                            }
                        }
                    }
                    // Update immediately to ensure rendering
                    chunkManager.update(player.x, player.z);
                    addMessage('Teleported to spawn (dropped from y=100)');
                } else {
                    // Try to find a safe spot near the spawn point
                    let found = false;
                    for (let dy = 0; dy <= 5; dy++) {
                        if (!checkCollision(targetX, targetY + dy, targetZ)) {
                            player.x = targetX;
                            player.y = targetY + dy;
                            player.z = targetZ;
                            player.vy = 0;
                            player.onGround = false;
                            // Force-load chunks around new position
                            const newCx = Math.floor(targetX / CHUNK_SIZE);
                            const newCz = Math.floor(targetZ / CHUNK_SIZE);
                            chunkManager.preloadChunks(newCx, newCz, LOAD_RADIUS);
                            // Force rebuild of all nearby chunks
                            for (let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
                                for (let dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
                                    const cx = modWrap(newCx + dx, CHUNKS_PER_SIDE);
                                    const cz = modWrap(newCz + dz, CHUNKS_PER_SIDE);
                                    const chunk = chunkManager.getChunk(cx, cz);
                                    if (!chunk.generated) chunkManager.generateChunk(chunk);
                                    if (chunk.needsRebuild || !chunk.mesh) {
                                        chunkManager.buildChunkMesh(chunk);
                                    }
                                }
                            }
                            chunkManager.update(player.x, player.z);
                            addMessage(`Teleported near spawn (y=${Math.floor(targetY + dy)})`);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        // Fallback to surface level
                        player.x = targetX;
                        player.y = chunkManager.getSurfaceY(targetX, targetZ) + 1;
                        player.z = targetZ;
                        player.vy = 0;
                        player.onGround = true;
                        // Force-load chunks around new position
                        const newCx = Math.floor(targetX / CHUNK_SIZE);
                        const newCz = Math.floor(targetZ / CHUNK_SIZE);
                        chunkManager.preloadChunks(newCx, newCz, LOAD_RADIUS);
                        // Force rebuild of all nearby chunks
                        for (let dx = -LOAD_RADIUS; dx <= LOAD_RADIUS; dx++) {
                            for (let dz = -LOAD_RADIUS; dz <= LOAD_RADIUS; dz++) {
                                const cx = modWrap(newCx + dx, CHUNKS_PER_SIDE);
                                const cz = modWrap(newCz + dz, CHUNKS_PER_SIDE);
                                const chunk = chunkManager.getChunk(cx, cz);
                                if (!chunk.generated) chunkManager.generateChunk(chunk);
                                if (chunk.needsRebuild || !chunk.mesh) {
                                    chunkManager.buildChunkMesh(chunk);
                                }
                            }
                        }
                        chunkManager.update(player.x, player.z);
                        addMessage('Spawn point obstructed, placed at surface');
                    }
                }
            });

            document.getElementById('camToggle').addEventListener('click', toggleCameraMode);
            document.getElementById('openCraft').addEventListener('click', openCrafting);
            document.getElementById('teleportBtn').addEventListener('click', () => {
                isPromptOpen = true;
                document.getElementById('teleportModal').style.display = 'block';
                document.getElementById('teleportX').value = '';
                document.getElementById('teleportY').value = '';
                document.getElementById('teleportZ').value = '';
            });
            document.getElementById('saveChangesBtn').addEventListener('click', downloadSession);
            document.getElementById('joinScriptBtn').addEventListener('click', async () => {
                isPromptOpen = true;
                const userAddr = await GetPublicAddressByKeyword(`${userName}@${worldName}`);
                const masterAddr = await GetPublicAddressByKeyword(MASTER_WORLD_KEY);
                // Join addresses without quotes
                const joinScript = [userAddr || `${userName}@${worldName}`, masterAddr || MASTER_WORLD_KEY].filter(a => a).join(',').replace(/["']/g, '');
                document.getElementById('joinScriptText').value = joinScript;
                document.getElementById('joinScriptModal').style.display = 'block';
            });

            document.getElementById('newUserJoinScriptBtn').addEventListener('click', async () => {
                isPromptOpen = true;
                const worldInput = document.getElementById('worldNameInput').value;
                const userInput = document.getElementById('userInput').value;
                if (worldInput.length > 8) {
                    addMessage('World name too long (max 8 chars)', 3000);
                    return;
                }
                if (userInput.length > 20) {
                    addMessage('Username too long (max 20 chars)', 3000);
                    return;
                }
                if (!worldInput || !userInput) {
                    addMessage('Please enter a world and username', 3000);
                    return;
                }
                const cleanWorld = worldInput.replace(/[^a-zA-Z0-9]/g, '').slice(0, 8);
                const cleanUser = userInput.replace(/[^a-zA-Z0-9]/g, '');
                const userWorldKey = `${cleanUser}@${cleanWorld}`;
                const existingWorld = knownWorlds.get(cleanWorld);
                if (existingWorld && existingWorld.users.has(cleanUser)) {
                    addMessage('User already in this world. Choose a different username.', 3000);
                    return;
                }
                const userAddr = await GetPublicAddressByKeyword(userWorldKey);
                const masterAddr = await GetPublicAddressByKeyword(MASTER_WORLD_KEY);
                // Ensure addresses are trimmed and joined without quotes
                const addresses = [
                    userAddr ? userAddr.trim() : userWorldKey,
                    masterAddr ? masterAddr.trim() : MASTER_WORLD_KEY
                ].filter(a => a);
                const joinScript = addresses.join(',').replace(/["']/g, '');
                document.getElementById('joinScriptText').value = joinScript;
                document.getElementById('joinScriptModal').style.display = 'block';
            });
            document.getElementById('closeCraft').addEventListener('click', () => {
                isPromptOpen = false;
                document.getElementById('craftModal').style.display = 'none';
            });
            document.getElementById('closeJoinScript').addEventListener('click', () => {
                isPromptOpen = false;
                document.getElementById('joinScriptModal').style.display = 'none';
            });
            document.getElementById('closeDownloadModal').addEventListener('click', () => {
                isPromptOpen = false;
                document.getElementById('downloadModal').style.display = 'none';
            });
            document.getElementById('teleportCancel').addEventListener('click', () => {
                isPromptOpen = false;
                document.getElementById('teleportModal').style.display = 'none';
            });
            document.getElementById('teleportOk').addEventListener('click', () => {
                const x = parseFloat(document.getElementById('teleportX').value);
                const y = parseFloat(document.getElementById('teleportY').value);
                const z = parseFloat(document.getElementById('teleportZ').value);
                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    addMessage('Invalid coordinates', 3000);
                    return;
                }
                const newX = modWrap(x, MAP_SIZE);
                const newZ = modWrap(z, MAP_SIZE);
                if (!checkCollision(newX, y, newZ)) {
                    player.x = newX;
                    player.y = y;
                    player.z = newZ;
                    player.vy = 0;
                    player.onGround = true;
                    // Force-load chunks around new position
                    const newCx = Math.floor(newX / CHUNK_SIZE);
                    const newCz = Math.floor(newZ / CHUNK_SIZE);
                    chunkManager.preloadChunks(newCx, newCz, LOAD_RADIUS);
                    // Update immediately to ensure rendering
                    chunkManager.update(player.x, player.z);
                    addMessage(`Teleported to ${Math.floor(x)}, ${Math.floor(y)}, ${Math.floor(z)}`);
                    document.getElementById('teleportModal').style.display = 'none';
                    isPromptOpen = false;
                } else {
                    addMessage('Cannot teleport: obstructed', 3000);
                }
            });
            document.getElementById('respawnBtn').addEventListener('click', () => {
                respawnPlayer();
            });
            updateLoginUI();
            async function initWorldsAndUsers() {
                const masterAddr = await GetPublicAddressByKeyword(MASTER_WORLD_KEY);
                if (masterAddr) {
                    const messages = await GetPublicMessagesByAddress(masterAddr);
                    for (const msg of messages || []) {
                        if (msg.TransactionId && !processedMessages.has(msg.TransactionId)) {
                            const fromProfile = await GetProfileByAddress(msg.FromAddress);
                            if (!fromProfile || !fromProfile.URN) continue;
                            const user = fromProfile.URN.replace(/[^a-zA-Z0-9]/g, '');
                            const userProfile = await GetProfileByURN(user);
                            if (!userProfile || !userProfile.Creators || !userProfile.Creators.includes(msg.FromAddress)) continue;
                            const toKeywordRaw = await GetKeywordByPublicAddress(msg.ToAddress);
                            if (!toKeywordRaw) continue;
                            const toKeyword = toKeywordRaw.replace(/^"|"$/g, '');
                            if (!toKeyword.includes('MCUserJoin@')) continue;
                            const world = toKeyword.split('@')[1].replace(/[^a-zA-Z0-9]/g, '');
                            if (user && world) {
                                if (!knownWorlds.has(world)) {
                                    knownWorlds.set(world, { discoverer: user, users: new Set([user]), toAddress: msg.ToAddress });
                                } else {
                                    knownWorlds.get(world).users.add(user);
                                }
                                if (!knownUsers.has(user)) knownUsers.set(user, msg.FromAddress);
                                spawnChunks.set(user, { cx: null, cz: null, username: user, world });
                                processedMessages.add(msg.TransactionId);
                            }
                        }
                    }
                    console.log('%c[Init] Discovered worlds:', 'color: green', knownWorlds.size, 'users:', knownUsers.size);
                }
            }
            initWorldsAndUsers();
        });
    </script>
</body>
</html>