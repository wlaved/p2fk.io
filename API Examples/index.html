<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NFT Profile & Objects Lookup</title>
<style>
  body {
    background: #121212;
    color: #e0e0e0;
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    min-height: 100vh;
  }
  .container {
    padding: 15px;
    flex: 1;
    padding-top: 70px;
  }
  .search-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 15px;
    align-items: center;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: #121212;
    z-index: 1000;
    padding: 8px 15px;
  }
  .search-bar input[type="text"], .search-bar select {
    padding: 8px;
    background: #1e1e1e;
    border: 1px solid #333;
    color: #e0e0e0;
    border-radius: 5px;
    flex: 1 1 200px;
  }
  .search-bar input[type="text"] { max-width: 280px; }
  .search-bar label, .search-bar select {
    flex: 0 0 auto;
  }
  .filter-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    flex: 1 1 auto;
  }
  .filter-buttons button {
    padding: 4px 6px;
    background: #333;
    border: none;
    color: #bb86fc;
    border-radius: 3px;
    cursor: pointer;
    font-size: 0.7em;
    text-decoration: underline;
  }
  .filter-buttons button:hover { background: #7c4dff; color: #e0e0e0; }
  .filter-buttons button.active { background: #6200ea; color: #e0e0e0; }
  .object-count {
    color: #b0b0b0;
    font-size: 0.85em;
    margin-left: 8px;
    flex: 0 0 auto;
  }
  .profile-section {
    display: none;
    background: #1e1e1e;
    padding: 12px;
    border-radius: 8px;
    margin-bottom: 12px;
    max-width: 960px;
    position: relative;
  }
  .profile-content {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding-bottom: 3px;
  }
  .profile-header {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    flex: 0 0 auto;
  }
  .profile-image-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-shrink: 0;
  }
  .profile-section img {
    width: 90px;
    height: 90px;
    object-fit: cover;
    border-radius: 8px;
  }
  .bio-container {
    flex: 0 0 auto;
    max-width: 310px;
    color: #e0e0e0;
  }
  .name-social-container {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 2px;
  }
  .details-container {
    display: flex;
    flex-direction: column;
    gap: 2px;
    flex: 1;
    max-width: 100%;
  }
  .profile-content h2 {
    margin: 0;
    color: #bb86fc;
    font-size: 1.1em;
    display: inline-block;
  }
  .bio-container p {
    margin: 0;
    font-size: 0.85em;
    color: #e0e0e0;
  }
  .details-container p {
    margin: 0;
    font-size: 0.85em;
  }
  .social-link a {
    color: #bb86fc;
    text-decoration: none;
    background: none;
    border: 1px solid #bb86fc;
    border-radius: 10px;
    padding: 2px 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: inline-block;
    font-size: 0.65em;
  }
  .social-link a:hover {
    color: #fff;
    background: #7c4dff;
    border-color: #7c4dff;
    transform: scale(1.1);
  }
  .date-label {
    font-size: 0.75em;
    color: #b0b0b0;
    position: relative;
    cursor: default;
  }
  .date-tooltip {
    visibility: hidden;
    background: #333;
    color: #e0e0e0;
    padding: 4px 6px;
    border-radius: 4px;
    position: absolute;
    z-index: 1000;
    top: -22px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.7em;
    white-space: nowrap;
  }
  .date-label:hover .date-tooltip {
    visibility: visible;
  }
  .objects-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 15px;
    padding: 0 15px;
  }
  .object-card {
    background: #1e1e1e;
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    cursor: pointer;
    transition: transform 0.2s;
    position: relative;
  }
  .object-card:hover { transform: translateY(-5px); }
  .object-card img {
    width: 100%;
    height: 140px;
    object-fit: cover;
    border-radius: 5px;
  }
  .object-card h3 { margin: 8px 0; color: #bb86fc; }
  .object-card p { margin: 4px 0; font-size: 0.85em; color: #b0b0b0; }
  .unit-qty, .owned-qty, .urn-source-label, .listing-price {
    position: absolute;
    background: rgba(0, 0, 0, 0.7);
    color: #e0e0e0;
    padding: 2px 4px;
    border-radius: 3px;
    font-size: 0.75em;
  }
  .owned-qty { bottom: 20px; right: 4px; color: #03dac6; }
  .unit-qty { bottom: 4px; right: 4px; color: #bb86fc; }
  .listing-price {
    bottom: 12px;
    right: 12px;
    background: #03dac6;
    color: #121212;
    max-width: calc(100% - 24px);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .urn-source-label { top: 4px; left: 4px; z-index: 10; }
  .status { font-weight: bold; color: #03dac6; }
  .forged { color: #cf6679; font-style: italic; }
  .loading, .error { text-align: center; padding: 15px; color: #b0b0b0; }
  .error { color: #cf6679; }
  .urn-link { color: #bb86fc; cursor: pointer; text-decoration: underline; }
  .urn-link:hover { color: #7c4dff; }
  .unacknowledged { color: #666; font-style: italic; }
  .unacknowledged::after { content: ' (U)'; font-size: 0.75em; color: #888; }
  .image-error {
    width: 100%;
    height: 140px;
    background: #333;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #e0e0e0;
    font-size: 0.85em;
    border-radius: 5px;
    position: relative;
  }
  .modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 2000;
    justify-content: center;
    align-items: center;
  }
  .modal-content {
    background: #1e1e1e;
    padding: 15px;
    border-radius: 8px;
    max-width: 580px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
  }
  .modal-content img {
    width: 100%;
    max-height: 280px;
    object-fit: contain;
    border-radius: 5px;
    margin-bottom: 12px;
  }
  .modal-content h2 { color: #bb86fc; margin: 8px 0; }
  .modal-content p { margin: 4px 0; }
  .modal-close {
    position: absolute;
    top: 8px;
    right: 8px;
    background: #cf6679;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 5px;
    cursor: pointer;
    z-index: 2050;
  }
  .modal-close:hover { background: #e57373; }
  .modal-nav {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    background: #6200ea;
    color: white;
    border: none;
    padding: 10px 12px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.3em;
    z-index: 2100;
    box-shadow: 0 4px 8px rgba(0,0,0,0.4);
  }
  .modal-nav:hover { background: #7c4dff; }
  .modal-nav:disabled { background: #333; cursor: not-allowed; opacity: 0.5; }
  .urn-row { display: flex; align-items: center; gap: 6px; margin: 8px 0; flex-wrap: wrap; }
  .refresh-btn {
    background: none;
    border: none;
    color: #03dac6;
    font-size: 1.2em;
    cursor: pointer;
    padding: 5px;
    border-radius: 5px;
    order: -1;
  }
  .refresh-btn:hover { color: #7c4dff; }
  .refresh-btn.loading { animation: spin 1s linear infinite; transform-origin: center; }
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
  .creators-list, .owners-list, .changelog {
    max-height: 140px;
    overflow-y: auto;
    background: #121212;
    padding: 8px;
    border-radius: 5px;
    margin-top: 8px;
    font-size: 0.85em;
    color: #b0b0b0;
    max-width: 100%;
    word-break: break-word;
    overflow-x: hidden;
  }
  .changelog-entry { white-space: normal; word-break: break-word; }
  .urn-tooltip { display: none; }
  .keyword-link { color: #bb86fc; cursor: pointer; text-decoration: underline; }
  .keyword-link:hover { color: #7c4dff; }
  @media (max-width: 768px) {
    .profile-header {
      flex-direction: column;
      align-items: stretch;
    }
    .profile-image-container {
      align-items: flex-start;
    }
    .bio-container {
      max-width: 100%;
    }
    .details-container {
      max-width: 100%;
    }
    .name-social-container {
      flex-wrap: wrap;
    }
  }
  @media (min-width: 769px) {
    .profile-content {
      flex-direction: row;
      align-items: flex-start;
      gap: 12px;
    }
    .profile-header {
      max-width: 450px;
      flex: 0 0 auto;
    }
    .details-container {
      flex: 1;
      min-width: 0;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <div class="search-bar">
      <input type="text" id="urnInput" placeholder="Enter URN (e.g., embii4u) or #keyword">
      <label><input type="checkbox" id="mainnetToggle"> Mainnet</label>
      <select id="sortSelect">
        <option value="newest">Newest</option>
        <option value="oldest">Oldest</option>
        <option value="highestPrice">Highest Price</option>
        <option value="lowestPrice">Lowest Price</option>
        <option value="highestActivity">Highest Activity</option>
      </select>
      <div class="filter-buttons">
        <button id="filterAll" class="active" onclick="filterObjects('all')">All</button>
        <button id="filterCreated" onclick="filterObjects('created')">Created</button>
        <button id="filterOwned" onclick="filterObjects('owned')">Owned</button>
      </div>
      <div id="objectCount" class="object-count" style="display: none;"></div>
    </div>
    <div id="profileSection" class="profile-section">
      <div class="profile-content">
        <div class="profile-header">
          <div class="profile-image-container">
            <img id="profileImage" src="" alt="Profile Image">
          </div>
          <div class="bio-container">
            <div class="name-social-container">
              <h2 id="profileName"></h2>
              <div class="social-link">
                <a id="socialLink" href="#" target="_blank">Social</a>
              </div>
            </div>
            <p id="profileBio"></p>
          </div>
        </div>
        <div class="details-container">
          <p id="profileLocation"></p>
          <p id="profileLinks"></p>
          <p id="profileCreated" class="date-label"></p>
          <p id="profileChanged" class="date-label"></p>
        </div>
      </div>
    </div>
    <div id="objectsGrid" class="objects-grid"></div>
    <div id="loading" class="loading" style="display: none;">Loading more objects...</div>
    <div id="error" class="error" style="display: none;"></div>
  </div>
  <div id="modalOverlay" class="modal-overlay" aria-hidden="true">
    <button id="modalNavLeft" class="modal-nav" aria-label="Previous object" style="display:none;" onclick="navigateObject(-1)">&larr;</button>
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="modalName">
      <button class="modal-close" onclick="closeModal()">X</button>
      <img id="modalImage" src="" alt="Object Image">
      <h2 id="modalName"></h2>
      <p id="modalDescription"></p>
      <div class="urn-row">
        <button id="refreshButton" class="refresh-btn" title="Refresh object (verbose)">üîÑ</button>
        <span id="modalURN"></span>
      </div>
      <p id="modalBuyStatus"></p>
      <p id="modalOwners"></p>
      <div id="modalCreators" class="creators-list"></div>
      <p id="modalRoyalties"></p>
      <div id="modalChangelog" class="changelog"></div>
    </div>
    <button id="modalNavRight" class="modal-nav" aria-label="Next object" style="display:none;" onclick="navigateObject(1)">&rarr;</button>
  </div>
  <script>
  const state = {
    skip: 0,
    batchSize: 20,
    isLoading: false,
    hasMore: true,
    currentURN: '',
    creatorAddress: '',
    allObjects: [],
    retryDelay: 2000,
    displayedObjectIds: new Set(),
    totalObjects: 0,
    isSearching: false,
    currentObjectIndex: -1,
    currentMainnet: false,
    imageCache: new Map(),
    keywordCache: new Map(),
    filterType: 'all',
    filteredObjects: [],
    fallbackImage: "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='250' height='180'><rect width='100%' height='100%' fill='%23333'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='white' font-size='14'>No Image</text></svg>",
    actionIcons: { give: 'üéÅ', claim: 'üèÜ', list: 'üìã', burn: 'üî•', grant: 'üõ†Ô∏è', inspect: 'üîç', buy: 'üõçÔ∏è' }
  };

  const formatDateToLocalShort = (dateString) => {
    if (!dateString || dateString === 'N/A') return 'N/A';
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) return 'Invalid Date';
      return date.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    } catch {
      return 'Invalid Date';
    }
  };

  const formatDateToLocalFull = (dateString) => {
    if (!dateString || dateString === 'N/A') return 'N/A';
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) return 'Invalid Date';
      return date.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        timeZoneName: 'short'
      });
    } catch {
      return 'Invalid Date';
    }
  };

  const getCachedProfile = (address) => {
    const cached = sessionStorage.getItem(`profile_${address}`);
    return cached ? JSON.parse(cached) : null;
  };
  const cacheProfile = (address, profile) => sessionStorage.setItem(`profile_${address}`, JSON.stringify(profile));

  const getUrnSource = (urn, mainnet) => {
    if (!urn) return 'Unknown';
    if (/^(BTC|LTC|DOG|MZC):/i.test(urn)) return mainnet ? urn.split(':')[0].toUpperCase() : `${urn.split(':')[0].toUpperCase()}-T`;
    if (/^[A-Za-z0-9]+\/.+/.test(urn)) return mainnet ? 'BTC' : 'BTC-T';
    if (urn.startsWith('IPFS:')) return 'IPFS';
    if (/^(http|https):\/\//i.test(urn)) return 'HTTP' + (urn.startsWith('https') ? 'S' : '');
    return urn.length > 20 ? urn.slice(0, 20) + '...' : urn;
  };

  const fetchAPI = async (url, errorMsg) => {
    const response = await fetch(url);
    if (!response.ok) throw new Error(errorMsg);
    return response.json();
  };

  const fetchProfile = (urn, mainnet) => fetchAPI(
    `https://p2fk.io/GetProfileByURN/${encodeURIComponent(urn)}?mainnet=${mainnet}`,
    `Profile not found for URN: ${urn}`
  );

  const fetchObjectsByAddress = (address, mainnet) => fetchAPI(
    `https://p2fk.io/GetObjectsByAddress/${address}?skip=0&qty=-1&mainnet=${mainnet}&verbose=false`,
    `Objects not found for address: ${address}`
  );

  const fetchObjectsByKeyword = async (keyword, mainnet) => {
    const url = `https://p2fk.io/GetObjectsByKeyword/${encodeURIComponent(keyword)}?mainnet=${mainnet}&verbose=false`;
    return await fetchAPI(url, `Objects not found for keyword: ${keyword}`);
  };

  const fetchProfileByAddress = async (address, mainnet) => {
    const cached = getCachedProfile(address);
    if (cached) return cached;
    try {
      const profile = await fetchAPI(
        `https://p2fk.io/GetProfileByAddress/${address}?mainnet=${mainnet}`,
        `Profile not found for address: ${address}`
      );
      if (profile) cacheProfile(address, profile);
      return profile;
    } catch (e) {
      return null;
    }
  };

  const resolveUrnPath = (urn) => {
    if (!urn) return '';
    urn = urn.replace(/\\/g, '/');
    const parts = urn.split(':').pop().split('/');
    return /^(BTC|LTC|DOG|MZC):/i.test(urn) || /^[A-Za-z0-9]+\/.+/.test(urn)
      ? `https://bitfossil.org/${parts[0]}/${parts[1] || ''}`
      : '';
  };

  const getImageUrl = (image, urn) => {
    const normalize = (input) => typeof input === "string" ? input.replace(/\\/g, "/").replace(/\/{2,}/g, "/") : null;
    const resolve = (input) => {
      if (!input) return null;
      const value = normalize(input);
      const lower = value.toLowerCase();
      if (/^https?:\/\//i.test(value) && /\.(jpg|jpeg|png|gif|ico|bmp|webp)$/i.test(value)) {
        return value.replace(/^http:\/\/bitfossil\.com\//i, "https://bitfossil.org/").replace(/^http:/i, "https:");
      }
      if (lower.startsWith("ipfs")) {
        const hash = value.replace(/^ipfs[:/]+/i, "").split("/")[0];
        return hash ? `https://ipfs.io/ipfs/${hash}` : null;
      }
      return /^(BTC|LTC|DOG|MZC):/i.test(value) || /^[A-Za-z0-9]+\/.+/.test(value) ? resolveUrnPath(value) : null;
    };
    return resolve(image) || resolve(urn) || state.fallbackImage;
  };

  const resizeImage = async (img, maxSize = 1024) => {
    const { width, height } = img;
    const canvas = document.createElement('canvas');
    if (width <= maxSize && height <= maxSize) {
      canvas.width = width;
      canvas.height = height;
    } else {
      const ratio = Math.min(maxSize / width, maxSize / height);
      canvas.width = width * ratio;
      canvas.height = height * ratio;
    }
    canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/jpeg', 0.8);
  };

  const loadImageWithTimeout = async (url, timeout = 180000) => {
    if (state.imageCache.has(url)) return state.imageCache.get(url);
    if (url === state.fallbackImage) return url;
    try {
      const img = new Image();
      if (!url.includes('bitfossil.org')) img.crossOrigin = 'Anonymous';
      const result = await new Promise((resolve, reject) => {
        const timer = setTimeout(() => reject(new Error('Timeout')), timeout);
        img.onload = async () => {
          clearTimeout(timer);
          const resizedUrl = url.includes('bitfossil.org') ? url : await resizeImage(img, 1024);
          state.imageCache.set(url, resizedUrl);
          resolve(resizedUrl);
        };
        img.onerror = () => {
          clearTimeout(timer);
          reject(new Error('Error loading'));
        };
        img.src = url;
      });
      return result;
    } catch (error) {
      state.imageCache.set(url, url);
      return url;
    }
  };

  const abbreviateAddress = (address) => address ? `${address.slice(0, 6)}...${address.slice(-4)}` : '';

  const createSearchLink = (text, mainnet, isUnacknowledged = false) => {
    if (!text) return '';
    const urn = text.startsWith('@') ? text.slice(1) : text;
    return `<span class="urn-link${isUnacknowledged ? ' unacknowledged' : ''}" onclick="searchProfile('${urn.replace(/'/g, "\\'")}', ${mainnet})">${text}</span>`;
  };

  const displayProfile = async (profile, mainnet, isKeywordSearch = false, searchTerm = '') => {
    const $ = (id) => document.getElementById(id);
    const keywordImage = isKeywordSearch ? `data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'><rect width='100%' height='100%' fill='%23333' rx='10'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#bb86fc' font-size='14' font-family='Arial'>${encodeURIComponent(searchTerm)}</text></svg>` : null;
    const imageUrl = isKeywordSearch ? keywordImage : getImageUrl(profile.Image, profile.URN);
    $('profileImage').src = state.fallbackImage;
    loadImageWithTimeout(imageUrl).then(url => $('profileImage').src = url).catch(() => $('profileImage').src = state.fallbackImage);
    $('profileName').textContent = isKeywordSearch ? `Keyword Search: ${searchTerm}` : (profile.DisplayName || profile.URN || 'Unknown');
    $('profileBio').textContent = isKeywordSearch ? 'Keyword-derived address' : (profile.Bio || 'No bio available');
    $('profileLocation').textContent = isKeywordSearch ? 'N/A' : (profile.Location?.quark || 'Unknown');
    $('profileLinks').innerHTML = !isKeywordSearch && profile.URL
      ? Object.entries(profile.URL || {}).map(([k, v]) =>
          v.startsWith('@')
            ? `<span class="urn-link" onclick="searchProfile('${v.slice(1).replace(/'/g, "\\'")}', ${mainnet})">${k}</span>`
            : `<a href="${v}" target="_blank" style="color:#bb86fc;">${k}</a>`
        ).join(' | ') || 'None'
      : 'None';
    const createdDateShort = isKeywordSearch ? 'N/A' : formatDateToLocalShort(profile.CreatedDate);
    const createdDateFull = isKeywordSearch ? 'N/A' : formatDateToLocalFull(profile.CreatedDate);
    const changedDateShort = isKeywordSearch ? 'N/A' : formatDateToLocalShort(profile.ChangeDate);
    const changedDateFull = isKeywordSearch ? 'N/A' : formatDateToLocalFull(profile.ChangeDate);
    $('profileCreated').innerHTML = createdDateShort === 'N/A' ? 'N/A' : `Created: ${createdDateShort}<span class="date-tooltip">${createdDateFull}</span>`;
    $('profileChanged').innerHTML = changedDateShort === 'N/A' ? 'N/A' : `Last Modified: ${changedDateShort}<span class="date-tooltip">${changedDateFull}</span>`;
    $('socialLink').href = isKeywordSearch 
      ? `SupThread.html?mainnet=${mainnet}&urn=${encodeURIComponent(state.currentURN)}`
      : `SupThread.html?mainnet=${mainnet}&urn=${encodeURIComponent(profile.URN || state.currentURN)}`;
    $('profileSection').style.display = 'block';
    state.creatorAddress = isKeywordSearch ? state.creatorAddress : (profile?.Creators[0] || '');
  };

  const displayObjects = async (objects, mainnet) => {
    const objectsGrid = document.getElementById('objectsGrid');
    for (const obj of objects) {
      const creatorKeys = Object.keys(obj.Creators || {});
      const objectAddress = creatorKeys[0] || obj.URN || JSON.stringify(obj);
      if (state.displayedObjectIds.has(objectAddress)) continue;
      state.displayedObjectIds.add(objectAddress);
      const creators = creatorKeys.slice(1);
      const [collectionProfile, additionalProfile] = await Promise.all([
        creators[0] ? fetchProfileByAddress(creators[0], mainnet) : null,
        creators[1] ? fetchProfileByAddress(creators[1], mainnet) : null
      ]);
      const collectionURN = collectionProfile ? collectionProfile.URN || collectionProfile.DisplayName || abbreviateAddress(creators[0]) : creators[0] ? abbreviateAddress(creators[0]) : '';
      const additionalCreatorURN = additionalProfile ? additionalProfile.URN || additionalProfile.DisplayName || abbreviateAddress(creators[1]) : creators[1] ? abbreviateAddress(creators[1]) : '';
      const isCollectionUnacknowledged = creators[0] && obj.Creators[creators[0]] === "0001-01-01T00:00:00";
      const isAdditionalUnacknowledged = creators[1] && obj.Creators[creators[1]] === "0001-01-01T00:00:00";
      const totalUnits = Object.values(obj.Owners || {}).reduce((sum, owner) => sum + (owner.Item1 || 0), 0);
      const ownedUnits = obj.Owners?.[state.creatorAddress]?.Item1 || 0;
      const lowestPrice = obj.Listings && Object.keys(obj.Listings).length > 0
        ? Math.min(...Object.values(obj.Listings).map(l => l.Value))
        : null;
      const description = obj.Description ? obj.Description.substring(0, 100) + (obj.Description.length > 100 ? '...' : '') : '';
      const imageUrl = getImageUrl(obj.Image, obj.URN);
      const urnSource = getUrnSource(obj.URN, mainnet);
      const card = document.createElement('div');
      card.className = 'object-card';
      card.dataset.address = objectAddress;
      card.innerHTML = `
        <div style="position: relative;">
          <img src="${state.fallbackImage}" alt="${obj.Name || 'Object'}" style="display: block;">
          <span class="urn-source-label">${urnSource}<span class="urn-tooltip">${obj.URN || 'No URN'}</span></span>
          ${ownedUnits > 0 ? `<span class="owned-qty">${ownedUnits} Owned</span>` : ''}
          <span class="unit-qty">${totalUnits} Units</span>
        </div>
        <h3>${obj.Name || 'Unnamed Object'}</h3>
        ${description ? `<p>${description}</p>` : ''}
        ${collectionURN ? `<p>${createSearchLink(collectionURN, mainnet, isCollectionUnacknowledged)}</p>` : ''}
        ${additionalCreatorURN ? `<p>${createSearchLink(additionalCreatorURN, mainnet, isAdditionalUnacknowledged)}</p>` : ''}
        ${lowestPrice !== null ? `<div class="listing-price">${lowestPrice} BTC</div>` : ''}
      `;
      card.onclick = () => {
        const index = state.filteredObjects.findIndex(o => Object.keys(o.Creators || {})[0] === card.dataset.address);
        if (index === -1) {
          console.error(`Object with address ${card.dataset.address} not found in filteredObjects`);
          showError('Object not found in current filter');
          return;
        }
        showObjectDetails(index, mainnet);
      };
      objectsGrid.appendChild(card);
      loadImageWithTimeout(imageUrl).then(url => {
        const img = card.querySelector('img');
        img.src = url;
        img.style.display = 'block';
      }).catch(() => {
        card.querySelector('div').innerHTML = `
          <div class="image-error">Unable to fetch image</div>
          <span class="urn-source-label">${urnSource}<span class="urn-tooltip">${obj.URN || 'No URN'}</span></span>
          ${ownedUnits > 0 ? `<span class="owned-qty">${ownedUnits} Owned</span>` : ''}
          <span class="unit-qty">${totalUnits} Units</span>
        `;
      });
    }
  };

  const renderUrnLink = (urn) => {
    if (!urn) return 'URN: None';
    if (urn.startsWith('IPFS:') || /^ipfs[:/]+/i.test(urn)) {
      const hash = urn.replace(/^ipfs[:/]+/i, "").split("/")[0];
      return `URN: <a href="https://ipfs.io/ipfs/${hash}" target="_blank" style="color:#bb86fc">${urn}</a>`;
    }
    if (/^(BTC|LTC|DOG|MZC):/i.test(urn) || /^[A-Za-z0-9]+\/.+/.test(urn)) {
      const parts = urn.split(':').pop().split('/');
      return `URN: <a href="https://bitfossil.org/${parts[0]}/${parts[1] || ''}" target="_blank" style="color:#bb86fc">${urn}</a>`;
    }
    return `URN: ${urn}`;
  };const showObjectDetails = async (index, mainnet) => {
    if (index < 0 || index >= state.filteredObjects.length) {
      console.error(`Invalid index: ${index}, filteredObjects length: ${state.filteredObjects.length}`);
      showError('Invalid object index');
      return;
    }
    try {
      state.currentObjectIndex = index;
      const obj = state.filteredObjects[index];
      const $ = (id) => document.getElementById(id);
      const modalOverlay = $('modalOverlay');
      const modalImage = $('modalImage');
      const imageUrl = getImageUrl(obj.Image, obj.URN);
      modalImage.src = state.fallbackImage;
      loadImageWithTimeout(imageUrl).then(url => modalImage.src = url).catch(() => modalImage.src = state.fallbackImage);
      $('modalName').textContent = obj.Name || 'Unnamed Object';
      $('modalDescription').textContent = `Description: ${obj.Description || 'No description available'}`;
      const isAvailable = obj.Listings && Object.keys(obj.Listings).length > 0;
      const lowestPrice = isAvailable ? Math.min(...Object.values(obj.Listings).map(l => l.Value)) : null;
      $('modalBuyStatus').className = `buy-status ${isAvailable ? 'available' : 'not-available'}`;
      $('modalBuyStatus').textContent = isAvailable ? `Available for purchase: ${lowestPrice} BTC` : 'Not available for purchase';
      const objectAddress = Object.keys(obj.Creators || {})[0] || 'Unknown';
      const creatorsList = await Promise.all(
        Object.entries(obj.Creators || {}).filter(([addr]) => addr !== objectAddress).map(async ([address, date]) => {
          const isUnacknowledged = date === "0001-01-01T00:00:00";
          const profile = await fetchProfileByAddress(address, mainnet);
          const name = profile ? profile.DisplayName || profile.URN || abbreviateAddress(address) : abbreviateAddress(address);
          return createSearchLink(name, mainnet, isUnacknowledged);
        })
      );
      $('modalCreators').innerHTML = `<p>Creators: ${creatorsList.length ? creatorsList.join(', ') : 'None'}</p>`;
      const ownersList = await Promise.all(
        Object.entries(obj.Owners || {}).map(async ([address, { Item1: units }]) => {
          const profile = await fetchProfileByAddress(address, mainnet);
          const name = profile ? profile.DisplayName || profile.URN || abbreviateAddress(address) : abbreviateAddress(address);
          return address === objectAddress ? `Primary: ${units} Units` : `${createSearchLink(name, mainnet)}: ${units} Units`;
        })
      );
      $('modalOwners').innerHTML = `<p>Owners: ${ownersList.length ? ownersList.join(', ') : 'None'}</p>`;
      $('modalOwners').className = 'owners-list';
      const royaltiesList = Object.entries(obj.Royalties || {}).map(([addr, perc]) => `${abbreviateAddress(addr)}: ${perc}%`);
      $('modalRoyalties').textContent = `Royalties: ${royaltiesList.length ? royaltiesList.join(', ') : 'None'}`;
      const changelog = (obj.ChangeLog || []).slice().reverse().map(entry => {
        try {
          if (typeof entry === 'string') {
            const [from, to, action, qty, details, status, date] = JSON.parse(entry);
            const actionIcon = state.actionIcons[action.toLowerCase()] || '‚öôÔ∏è';
            const statusClass = status.toLowerCase().includes('success') ? 'status-success' : 'status-failed';
            return `<div class="changelog-entry ${statusClass}">
                      <span class="action-icon ${action.toLowerCase()}">${actionIcon}</span>
                      <span>${date || 'Unknown date'}: ${action} by ${abbreviateAddress(from)} to ${abbreviateAddress(to)}${qty ? ` (Qty: ${qty})` : ''}${details ? ` (${details})` : ''}</span>
                    </div>`;
          }
          return `<div class="changelog-entry"><span>${entry.Date || 'Unknown date'}: ${entry.Description || 'No details'}</span></div>`;
        } catch (error) {
          return `<div class="changelog-entry"><span>Invalid changelog entry</span></div>`;
        }
      });
      $('modalChangelog').innerHTML = changelog.length ? changelog.join('') : '<p>No changelog available</p>';
      $('modalURN').innerHTML = renderUrnLink(obj.URN);
      $('refreshButton').onclick = () => refreshSingleObject(obj, mainnet);
      // Update navigation button states
      const navLeft = $('modalNavLeft');
      const navRight = $('modalNavRight');
      navLeft.style.display = 'block';
      navRight.style.display = 'block';
      navLeft.disabled = index === 0;
      navRight.disabled = index === state.filteredObjects.length - 1;
      modalOverlay.style.display = 'flex';
      modalOverlay.setAttribute('aria-hidden', 'false');
      positionModalNavButtons();
    } catch (error) {
      console.error('Error in showObjectDetails:', error);
      showError('Error displaying object details');
    }
};

  const showError = (msg) => {
    const errorEl = document.getElementById('error');
    errorEl.textContent = msg;
    errorEl.style.display = 'block';
    document.getElementById('modalOverlay').style.display = 'none';
  };

  const closeModal = () => {
    document.getElementById('modalOverlay').style.display = 'none';
    document.getElementById('modalOverlay').setAttribute('aria-hidden', 'true');
    state.currentObjectIndex = -1;
  };

  const navigateObject = (direction) => {
    const newIndex = state.currentObjectIndex + direction;
    if (newIndex >= 0 && newIndex < state.filteredObjects.length) {
      showObjectDetails(newIndex, document.getElementById('mainnetToggle').checked);
    }
  };

  const sortObjects = (objects, sortBy) => {
    const comparePrice = (a, b, order) => {
      const aHasListings = a.Listings && Object.keys(a.Listings).length > 0;
      const bHasListings = b.Listings && Object.keys(b.Listings).length > 0;
      if (!aHasListings && !bHasListings) return 0;
      if (!aHasListings) return 1;
      if (!bHasListings) return -1;
      const aPrice = Math.min(...Object.values(a.Listings).map(l => l.Value));
      const bPrice = Math.min(...Object.values(b.Listings).map(l => l.Value));
      return order === 'asc' ? aPrice - bPrice : bPrice - aPrice;
    };
    return [...objects].sort((a, b) => {
      if (sortBy === 'newest') return new Date(b.CreatedDate) - new Date(a.CreatedDate);
      if (sortBy === 'oldest') return new Date(a.CreatedDate) - new Date(b.CreatedDate);
      if (sortBy === 'highestPrice') return comparePrice(a, b, 'desc');
      if (sortBy === 'lowestPrice') return comparePrice(a, b, 'asc');
      if (sortBy === 'highestActivity') return (b.ProcessHeight || 0) - (a.ProcessHeight || 0);
      return 0;
    });
  };

  const updateObjectCount = () => {
    const $ = (id) => document.getElementById(id);
    $('objectCount').textContent = `Total Objects: ${state.totalObjects} | Displayed: ${Math.min(state.skip, state.totalObjects)}`;
    $('objectCount').style.display = state.totalObjects > 0 ? 'inline-block' : 'none';
    if (state.totalObjects === 0) {
      $('objectsGrid').innerHTML = '<div class="loading">No objects found for this filter.</div>';
    }
  };

  const filterObjects = (filterType) => {
    state.filterType = filterType;
    state.skip = 0;
    state.hasMore = true;
    state.displayedObjectIds.clear();
    document.getElementById('objectsGrid').innerHTML = '';
    const $ = (id) => document.getElementById(id);
    ['filterAll', 'filterCreated', 'filterOwned'].forEach(id => {
      $(id).classList.remove('active');
    });
    $(`filter${filterType.charAt(0).toUpperCase() + filterType.slice(1)}`).classList.add('active');
    state.filteredObjects = state.allObjects.filter(obj => {
      if (filterType === 'all') return true;
      if (filterType === 'created') {
        return Object.entries(obj.Creators || {}).some(([addr, date]) => 
          addr === state.creatorAddress && date !== "0001-01-01T00:00:00"
        );
      }
      if (filterType === 'owned') {
        return obj.Owners?.[state.creatorAddress]?.Item1 > 0;
      }
      return true;
    });
    state.filteredObjects = sortObjects(state.filteredObjects, $('sortSelect').value); // Apply sort after filtering
    state.totalObjects = state.filteredObjects.length;
    updateObjectCount();
    loadObjects(document.getElementById('mainnetToggle').checked);
  };

  const loadObjects = async (mainnet) => {
    if (state.isLoading) return;
    state.isLoading = true;
    const $ = (id) => document.getElementById(id);
    $('loading').style.display = 'block';
    $('error').style.display = 'none';
    try {
      if (!state.allObjects.length && state.creatorAddress) {
        state.allObjects = await fetchObjectsByAddress(state.creatorAddress, mainnet);
        state.filteredObjects = sortObjects(state.allObjects, $('sortSelect').value); // Initialize with sorted objects
        state.totalObjects = state.allObjects.length;
        if (!state.totalObjects) {
          $('loading').style.display = 'none';
          $('objectsGrid').innerHTML = '<div class="loading">No objects found.</div>';
          setTimeout(() => {
            state.isLoading = false;
            state.retryDelay = Math.min(state.retryDelay * 2, 30000);
            loadObjects(mainnet);
          }, state.retryDelay);
          return;
        }
        try {
          sessionStorage.setItem(getCacheKey(state.currentURN, mainnet), JSON.stringify(state.allObjects));
        } catch (e) {}
        state.retryDelay = 2000;
      }
      const objectsToDisplay = state.filterType === 'all' ? state.allObjects : state.filteredObjects;
      state.totalObjects = objectsToDisplay.length;
      state.hasMore = state.skip < state.totalObjects;
      const batch = sortObjects(objectsToDisplay, $('sortSelect').value).slice(state.skip, state.skip + state.batchSize);
      if (!batch.length && state.totalObjects > 0) {
        state.hasMore = false;
        $('loading').style.display = 'none';
        state.isLoading = false;
        updateObjectCount();
        return;
      }
      if (state.totalObjects === 0) {
        $('objectsGrid').innerHTML = '<div class="loading">No objects found for this filter.</div>';
        state.hasMore = false;
        $('loading').style.display = 'none';
        state.isLoading = false;
        updateObjectCount();
        return;
      }
      await displayObjects(batch, mainnet);
      state.skip += batch.length;
      updateObjectCount();
    } catch (error) {
      showError(error.message);
      setTimeout(() => {
        state.isLoading = false;
        state.retryDelay = Math.min(state.retryDelay * 2, 30000);
        loadObjects(mainnet);
      }, state.retryDelay);
    } finally {
      state.isLoading = false;
      $('loading').style.display = 'none';
    }
  };

  const searchProfile = async (urn = null, mainnet = null) => {
    if (state.isSearching) return;
    state.isSearching = true;
    const inputUrn = urn || document.getElementById('urnInput').value.trim();
    const isMainnet = mainnet !== null ? mainnet : document.getElementById('mainnetToggle').checked;
    if (!inputUrn) {
      showError('Please enter a URN or #keyword');
      state.isSearching = false;
      return;
    }
    Object.assign(state, {
      creatorAddress: '',
      allObjects: [],
      filteredObjects: [],
      skip: 0,
      hasMore: true,
      retryDelay: 2000,
      displayedObjectIds: new Set(),
      totalObjects: 0,
      currentURN: inputUrn,
      filterType: 'all'
    });
    const $ = (id) => document.getElementById(id);
    $('error').style.display = 'none';
    $('objectsGrid').innerHTML = '';
    $('objectCount').style.display = 'none';
    $('loading').style.display = 'block';
    $('profileSection').style.display = 'none';
    ['filterAll', 'filterCreated', 'filterOwned'].forEach(id => {
      $(id).classList.remove('active');
    });
    $('filterAll').classList.add('active');
    $('urnInput').value = inputUrn;
    $('mainnetToggle').checked = isMainnet;
    const cacheKey = getCacheKey(inputUrn, isMainnet);
    try {
      let profile = null;
      let isKeywordSearch = inputUrn.startsWith('#');
      let searchTerm = isKeywordSearch ? inputUrn.slice(1) : inputUrn;
      if (isKeywordSearch) {
        const keywordAddress = await fetchAPI(
          `https://p2fk.io/GetPublicAddressByKeyword/${encodeURIComponent(searchTerm)}?mainnet=${isMainnet}`,
          `No address found for keyword: ${searchTerm}`
        );
        state.creatorAddress = keywordAddress;
        state.allObjects = await fetchObjectsByKeyword(searchTerm, isMainnet);
        state.filteredObjects = sortObjects(state.allObjects, $('sortSelect').value); // Initialize sorted
      } else {
        const cachedObjects = sessionStorage.getItem(cacheKey);
        if (cachedObjects) {
          state.allObjects = JSON.parse(cachedObjects);
          state.filteredObjects = sortObjects(state.allObjects, $('sortSelect').value); // Initialize sorted
          state.totalObjects = state.allObjects.length;
          profile = await fetchProfile(inputUrn, isMainnet);
        } else {
          profile = await fetchProfile(inputUrn, isMainnet);
          state.creatorAddress = profile?.Creators[0] || '';
          state.allObjects = await fetchObjectsByAddress(state.creatorAddress, isMainnet);
          state.filteredObjects = sortObjects(state.allObjects, $('sortSelect').value); // Initialize sorted
        }
      }
      await displayProfile(profile, isMainnet, isKeywordSearch, searchTerm);
      if (state.creatorAddress || isKeywordSearch) {
        state.totalObjects = state.allObjects.length;
        await loadObjects(isMainnet);
        updateObjectCount();
      } else {
        showError('No creator address found for profile');
      }
    } catch (error) {
      showError(error.message);
      $('profileSection').style.display = 'none';
    } finally {
      $('loading').style.display = 'none';
      state.isSearching = false;
    }
  };

  const getCacheKey = (urn, mainnet) => `objects_${urn}_${mainnet ? "mainnet" : "testnet"}`;

  const refreshSingleObject = async (obj, mainnet) => {
    const refreshBtn = document.getElementById('refreshButton');
    const objectAddress = Object.keys(obj.Creators || {})[0];
    if (!objectAddress) {
      alert("Cannot refresh: object address not found.");
      return;
    }
    const url = `https://p2fk.io/GetObjectByAddress/${encodeURIComponent(objectAddress)}?mainnet=${!!mainnet}&verbose=true`;
    refreshBtn.classList.add('loading');
    refreshBtn.disabled = true;
    try {
      const fresh = await fetchAPI(url, `Refresh failed for address: ${objectAddress}`);
      let updatedObject = Array.isArray(fresh)
        ? fresh.find(o => Object.keys(o.Creators || {})[0] === objectAddress)
        : fresh.URN && Object.keys(fresh.Creators || {})[0] === objectAddress
          ? fresh
          : fresh[obj.URN] || (Array.isArray(fresh.Items) ? fresh.Items.find(i => Object.keys(i.Creators || {})[0] === objectAddress) : fresh);
      if (!updatedObject) {
        alert("Refresh returned no recognizable object data.");
        return;
      }
      const idx = state.allObjects.findIndex(o => Object.keys(o.Creators || {})[0] === objectAddress);
      if (idx !== -1) {
        state.allObjects[idx] = updatedObject;
      } else {
        state.allObjects.push(updatedObject);
      }
      try {
        sessionStorage.setItem(getCacheKey(state.currentURN, mainnet), JSON.stringify(state.allObjects));
      } catch (e) {}
      // Update filteredObjects to reflect the refreshed object
      const filteredIdx = state.filteredObjects.findIndex(o => Object.keys(o.Creators || {})[0] === objectAddress);
      if (filteredIdx !== -1) {
        state.filteredObjects[filteredIdx] = updatedObject;
        // Re-sort filteredObjects to maintain sort order
        state.filteredObjects = sortObjects(state.filteredObjects, document.getElementById('sortSelect').value);
      }
      showObjectDetails(state.currentObjectIndex, mainnet);
    } catch (e) {
      alert("Error refreshing object: " + (e.message || e));
    } finally {
      refreshBtn.classList.remove('loading');
      refreshBtn.disabled = false;
    }
  };

  const positionModalNavButtons = () => {
    const overlay = document.getElementById('modalOverlay');
    if (!overlay || overlay.style.display === 'none') return;
    const modalContent = document.querySelector('.modal-content');
    const [leftBtn, rightBtn] = [document.getElementById('modalNavLeft'), document.getElementById('modalNavRight')];
    if (!modalContent || !leftBtn || !rightBtn) return;
    const rect = modalContent.getBoundingClientRect();
    const centerY = rect.top + rect.height / 2;
    const safeGap = 12;
    const leftX = Math.max(8, rect.left - leftBtn.offsetWidth - safeGap);
    const rightX = Math.min(window.innerWidth - rightBtn.offsetWidth - 8, rect.right + safeGap);
    leftBtn.style.cssText = `top: ${centerY}px; left: ${leftX}px; transform: translateY(-50%);`;
    rightBtn.style.cssText = `top: ${centerY}px; left: ${rightX}px; transform: translateY(-50%);`;
    if (leftX + leftBtn.offsetWidth + safeGap > rect.left) {
      leftBtn.style.left = `${Math.max(8, rect.left - leftBtn.offsetWidth - safeGap - 8)}px`;
    }
    if (rightX < rect.right + safeGap) {
      rightBtn.style.left = `${Math.min(window.innerWidth - rightBtn.offsetWidth - 8, rect.right + safeGap + 8)}px`;
    }
  };

  window.addEventListener('scroll', () => {
    if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 100 && !state.isSearching) {
      loadObjects(document.getElementById('mainnetToggle').checked);
    }
    positionModalNavButtons();
  });

  window.addEventListener('resize', positionModalNavButtons);

  document.getElementById('modalOverlay').addEventListener('click', (e) => {
    if (!document.querySelector('.modal-content').contains(e.target) && e.target.id === 'modalOverlay') {
      closeModal();
    }
  });

  document.getElementById('urnInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') searchProfile();
  });

  document.getElementById('sortSelect').addEventListener('change', () => {
    state.skip = 0;
    state.hasMore = true;
    state.displayedObjectIds.clear();
    document.getElementById('objectsGrid').innerHTML = '';
    closeModal();
    // Re-sort filteredObjects to match new sort order
    state.filteredObjects = sortObjects(state.filteredObjects, document.getElementById('sortSelect').value);
    state.totalObjects = state.filteredObjects.length;
    updateObjectCount();
    loadObjects(document.getElementById('mainnetToggle').checked);
  });

  document.getElementById('mainnetToggle').addEventListener('change', () => {
    state.currentMainnet = document.getElementById('mainnetToggle').checked;
  });

  state.currentMainnet = document.getElementById('mainnetToggle').checked;
</script>
</body>
</html>